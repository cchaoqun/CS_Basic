# 数据结构

 [二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)的概念？[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)又是什么，[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)和其他平衡树的区别在哪 

1. [平衡二叉树](https://www.nowcoder.com/jump/super-jump/word?word=平衡二叉树)是什么？用普通二叉搜索树不行吗？ [红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)和平衡树的区别 
2. 说一下对于树的理解
3. [二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)，二叉查找树，[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)
4. 堆排 快排 
5. LRU 

## 红黑树

https://blog.csdn.net/xiaofeng10330111/article/details/106080394?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162740012116780265489543%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162740012116780265489543&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-106080394.pc_search_result_before_js&utm_term=%E7%BA%A2%E9%BB%91%E6%A0%91&spm=1018.2226.3001.4187



TreeMap TreeSet HashMap

### 对红黑树的基本定义理解

红黑树的英文是“Red-Black Tree”，简称 R-B Tree，它是一种不严格的平衡二叉查找树

![image-20210728011623293](数据结构.assets/image-20210728011623293.png)

红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：

- 根节点是黑色的；
- 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据（图中将黑色的、空的叶子节点都省略掉了）；
- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
  -  每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

### 对红黑树是“近似平衡”的理解

平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重。

一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 log2n，所以如果要证明红黑树是近似平衡的，只需要分析，红黑树的高度是否比较稳定地趋近 log2n 就好了。

#### 1.将红色节点从红黑树中去掉，分析包含黑色节点的红黑树的高度

红色节点删除之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树。

![image-20210728011751505](数据结构.assets/image-20210728011751505.png)

从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。

完全二叉树的高度近似 log2n，这里的四叉“黑树”的高度要低于完全二叉树，所以去掉红色节点的“黑树”的高度也不会超过 log2n。


#### 把红色节点加回去，分析高度变化

在红黑树中，红色节点不能相邻，也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。

红黑树中包含最多黑色节点的路径不会超过 log2n，所以加入红色节点之后，最长路径不会超过 2log2n，也就是说，红黑树的高度近似 2log2n。

所以，红黑树的高度只比高度平衡的 AVL 树的高度（log2n）仅仅大了一倍，在性能上，下降得并不多。这样推导出来的结果不够精确，实际上红黑树的性能更好。


### **红黑树与AVL树的比较：**

- AVL树的时间复杂度虽然优于红黑树，但是对于现在的计算机，cpu太快，可以忽略性能差异
- 红黑树的插入删除比AVL树更便于控制操作
- 红黑树整体性能略优于AVL树（红黑树旋转情况少于AVL树）



### 实现红黑树的基本思想分析

红黑树的平衡过程跟魔方复原非常神似，大致过程就是：遇到什么样的节点排布，我们就对应怎么去调整。只要按照这些固定的调整规则来操作，就能将一个非平衡的红黑树调整成平衡的。

如上，一棵合格的红黑树需要满足的四个基本要求中，在插入、删除节点的过程中，第三、第四点要求可能会被破坏，而“平衡调整”实际上就是要把被破坏的第三、第四点恢复过来。具体分析如下：

#### 理解左旋（rotate left）、右旋（rotate right）操作

左旋就是围绕某个节点的左旋，图中的 a，b，r 表示子树，可以为空。

逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子

![image-20210728012014045](数据结构.assets/image-20210728012014045.png)

```java
/**
     * 功能描述：左旋右侧需要平衡
     *
     * @author yanfengzhang
     * @date 2020-05-27 14:57
     */
    private void rotateLeft(Entry<K, V> p) {
        if (p != null) {
            /*拿到根节点的右子节点 */
            Entry<K, V> r = p.right;
            /*把根节点的右子节点的左节点，赋值*/
            p.right = r.left;
            if (r.left != null)
                /*将根节点这个值赋值到当前断开的跟节点上*/ {
                r.left.parent = p;
            }
            /*r 将来要成为新的根节点 p.parent 为根 ，使得他为新的跟节点 */
            r.parent = p.parent;
            if (p.parent == null) {
                root = r;
            }
            /*如果p 为左孩子，让他还是成为左孩子 同理*/
            else if (p.parent.left == p) {
                p.parent.left = r;
            } else {
                p.parent.right = r;
            }
            /*最后 将当前交换的跟换值*/
            r.left = p;
            p.parent = r;
        }
    }
```

右旋就是围绕某个节点的右旋，图中的 a，b，r 表示子树，可以为空。

顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。

![image-20210728012107747](数据结构.assets/image-20210728012107747.png)

```java
    /**
     * 功能描述：右旋代码
     *
     * @author yanfengzhang
     * @date 2020-05-27 14:58
     */
    private void rotateRight(Entry<K, V> p) {
        if (p != null) {
            Entry<K, V> l = p.left;
            p.left = l.right;
            if (l.right != null) {
                l.right.parent = p;
            }
            l.parent = p.parent;
            if (p.parent == null) {
                root = l;
            } else if (p.parent.right == p) {
                p.parent.right = l;
            } else {
                p.parent.left = l;
            }
            l.right = p;
            p.parent = l;
        }
    }
```

#### 插入操作的平衡调整

红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。

关于插入操作的平衡调整，有这样两种特殊情况：

- 如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。
- 如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。

除此之外，其他情况都会违背红黑树的定义，需要进行调整，调整的过程包含两种基础的操作：左右旋转和改变颜色。

红黑树的平衡调整过程是一个迭代的过程。把正在处理的节点叫作关注节点。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。新节点插入之后，如果红黑树的平衡被打破，那一般会有下面三种情况：

备注：我们只需要根据每种情况的特点，不停地调整，就可以让红黑树继续符合定义，也就是继续保持平衡。为了简化描述，把父节点的兄弟节点叫作叔叔节点，父节点的父节点叫作祖父节点。

##### 情况一：如果关注节点是 a，它的叔叔节点 d 是红色

![image-20210728012325033](数据结构.assets/image-20210728012325033.png)

具体操作为：

- 将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；
- 将关注节点 a 的祖父节点 c 的颜色设置成红色；
- 关注节点变成 a 的祖父节点 c；
- 跳到情况二或者情况三。

##### 情况二：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点

![image-20210728012440700](数据结构.assets/image-20210728012440700.png)

具体操作为：关注节点变成节点 a 的父节点 b；围绕新的关注节点b 左旋；跳到情况三。

##### 情况三：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点

![image-20210728012523082](数据结构.assets/image-20210728012523082.png)



具体操作为：围绕关注节点 a 的祖父节点 c 右旋；将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换，调整结束。

```java
    /**
     * 功能描述：插入一个节点
     *
     * @author yanfengzhang
     * @date 2020-05-27 15:07
     */
    private void insert(RBTreeNode<T> node) {
        int cmp;
        RBTreeNode<T> root = this.rootNode;
        RBTreeNode<T> parent = null;
 
        /*定位节点添加到哪个父节点下*/
        while (null != root) {
            parent = root;
            cmp = node.key.compareTo(root.key);
            if (cmp < 0) {
                root = root.left;
            } else {
                root = root.right;
            }
        }
 
        node.parent = parent;
        /*表示当前没一个节点，那么就当新增的节点为根节点*/
        if (null == parent) {
            this.rootNode = node;
        } else {
            //找出在当前父节点下新增节点的位置
            cmp = node.key.compareTo(parent.key);
            if (cmp < 0) {
                parent.left = node;
            } else {
                parent.right = node;
            }
        }
 
        /*设置插入节点的颜色为红色*/
        node.color = COLOR_RED;
 
        /*修正为红黑树*/
        insertFixUp(node);
    }
 
    /**
     * 功能描述：红黑树插入修正
     *
     * @author yanfengzhang
     * @date 2020-05-27 15:07
     */
    private void insertFixUp(RBTreeNode<T> node) {
        RBTreeNode<T> parent, gparent;
        /*节点的父节点存在并且为红色*/
        while (((parent = getParent(node)) != null) && isRed(parent)) {
            gparent = getParent(parent);
 
            /*如果其祖父节点是空怎么处理, 若父节点是祖父节点的左孩子*/
            if (parent == gparent.left) {
                RBTreeNode<T> uncle = gparent.right;
                if ((null != uncle) && isRed(uncle)) {
                    setColorBlack(uncle);
                    setColorBlack(parent);
                    setColorRed(gparent);
                    node = gparent;
                    continue;
                }
 
                if (parent.right == node) {
                    RBTreeNode<T> tmp;
                    leftRotate(parent);
                    tmp = parent;
                    parent = node;
                    node = tmp;
                }
 
                setColorBlack(parent);
                setColorRed(gparent);
                rightRotate(gparent);
            } else {
                RBTreeNode<T> uncle = gparent.left;
                if ((null != uncle) && isRed(uncle)) {
                    setColorBlack(uncle);
                    setColorBlack(parent);
                    setColorRed(gparent);
                    node = gparent;
                    continue;
                }
 
                if (parent.left == node) {
                    RBTreeNode<T> tmp;
                    rightRotate(parent);
                    tmp = parent;
                    parent = node;
                    node = tmp;
                }
 
                setColorBlack(parent);
                setColorRed(gparent);
                leftRotate(gparent);
            }
        }
        setColorBlack(this.rootNode);
    }
```

#### 删除操作的平衡调整

删除操作的平衡调整分为两步：

- 第一步是针对删除节点初步调整。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；
- 第二步是针对关注节点进行二次调整，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。

##### 针对删除节点初步调整

红黑树的定义中“只包含红色节点和黑色节点”，经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。

备注：如果一个节点既可以是红色，也可以是黑色，图中用一半红色一半黑色来表示。如果一个节点是“红 - 黑”或者“黑 - 黑”，图中用左上角的一个小黑点来表示额外的黑色。

###### 情况一：如果要删除的节点是 a，它只有一个子节点 b

![image-20210728094943692](数据结构.assets/image-20210728094943692.png)



具体操作为：

- 删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作跟普通的二叉查找树的删除操作一样；
- 节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。
- 这种情况下，我们把节点 b 改为黑色；调整结束，不需要进行二次调整。

###### 情况二：如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c

![image-20210728095058803](数据结构.assets/image-20210728095058803.png)

具体操作为：

- 如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。
- 我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置。这一部分操作跟普通的二叉查找树的删除操作无异；
- 然后把节点 c 的颜色设置为跟节点 a 相同的颜色；
- 如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红 - 黑”或者“黑 - 黑”；
- 这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。

###### 情况三：如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点

![image-20210728095253934](数据结构.assets/image-20210728095253934.png)



具体操作为：

- 找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 CASE 1；
- 将节点 a 替换成后继节点 d；
- 把节点 d 的颜色设置为跟节点 a 相同的颜色；
- 如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；
- 这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。
  

##### 针对关注节点进行二次调整

初步调整之后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点。针对这个关注节点，再分四种情况来进行二次调整。

备注：二次调整是为了让红黑树中不存在相邻的红色节点。

###### 情况一：如果关注节点是 a，它的兄弟节点 c 是红色的

![image-20210728095456517](数据结构.assets/image-20210728095456517.png)

具体操作：

- 围绕关注节点 a 的父节点 b 左旋；
- 关注节点 a 的父节点 b 和祖父节点 c 交换颜色；
- 关注节点不变；继续从四种情况中选择适合的规则来调整。

###### 情况二：如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的

![image-20210728095528826](数据结构.assets/image-20210728095528826.png)



具体操作：

- 将关注节点 a 的兄弟节点 c 的颜色变成红色；
- 从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；
- 给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”；
- 关注节点从 a 变成其父节点 b；继续从四种情况中选择符合的规则来调整。
  

###### 情况三：如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色

![image-20210728095700631](数据结构.assets/image-20210728095700631.png)

具体操作：

- 围绕关注节点 a 的兄弟节点 c 右旋；
- 节点 c 和节点 d 交换颜色；
- 关注节点不变；
- 跳转到 CASE 4，继续调整。



###### 情况四：如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的

![image-20210728095815786](数据结构.assets/image-20210728095815786.png)

具体操作：

- 围绕关注节点 a 的父节点 b 左旋；
- 将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；
- 将关注节点 a 的父节点 b 的颜色设置为黑色；
- 从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；
- 将关注节点 a 的叔叔节点 e 设置为黑色；调整结束。
  

```java
    /**
     * 功能描述：删除节点
     *
     * @author yanfengzhang
     * @date 2020-05-27 15:11
     */
    private void remove(RBTreeNode<T> node) {
        RBTreeNode<T> child, parent;
        boolean color;
        /*被删除节点左右孩子都不为空的情况*/
        if ((null != node.left) && (null != node.right)) {
 
            /*获取到被删除节点的后继节点*/
            RBTreeNode<T> replace = node;
 
            replace = replace.right;
            while (null != replace.left) {
                replace = replace.left;
            }
 
            /*node节点不是根节点*/
            if (null != getParent(node)) {
                /*node是左节点*/
                if (getParent(node).left == node) {
                    getParent(node).left = replace;
                } else {
                    getParent(node).right = replace;
                }
            } else {
                this.rootNode = replace;
            }
 
            child = replace.right;
            parent = getParent(replace);
            color = getColor(replace);
 
            if (parent == node) {
                parent = replace;
            } else {
                if (null != child) {
                    setParent(child, parent);
                }
                parent.left = child;
 
                replace.right = node.right;
                setParent(node.right, replace);
            }
 
            replace.parent = node.parent;
            replace.color = node.color;
            replace.left = node.left;
            node.left.parent = replace;
            if (color == COLOR_BLACK) {
                removeFixUp(child, parent);
            }
 
            node = null;
            return;
        }
 
        if (null != node.left) {
            child = node.left;
        } else {
            child = node.right;
        }
 
        parent = node.parent;
        color = node.color;
        if (null != child) {
            child.parent = parent;
        }
 
        if (null != parent) {
            if (parent.left == node) {
                parent.left = child;
            } else {
                parent.right = child;
            }
        } else {
            this.rootNode = child;
        }
 
        if (color == COLOR_BLACK) {
            removeFixUp(child, parent);
        }
        node = null;
    }
 
    /**
     * 功能描述：删除修复
     *
     * @author yanfengzhang
     * @date 2020-05-27 15:11
     */
    private void removeFixUp(RBTreeNode<T> node, RBTreeNode<T> parent) {
        RBTreeNode<T> other;
        /*node不为空且为黑色，并且不为根节点*/
        while ((null == node || isBlack(node)) && (node != this.rootNode)) {
            /*node是父节点的左孩子*/
            if (node == parent.left) {
                /*获取到其右孩子*/
                other = parent.right;
                /*node节点的兄弟节点是红色*/
                if (isRed(other)) {
                    setColorBlack(other);
                    setColorRed(parent);
                    leftRotate(parent);
                    other = parent.right;
                }
 
                /*node节点的兄弟节点是黑色，且兄弟节点的两个孩子节点也是黑色*/
                if ((other.left == null || isBlack(other.left)) &&
                        (other.right == null || isBlack(other.right))) {
                    setColorRed(other);
                    node = parent;
                    parent = getParent(node);
                } else {
                    /*node节点的兄弟节点是黑色，且兄弟节点的右孩子是红色*/
                    if (null == other.right || isBlack(other.right)) {
                        setColorBlack(other.left);
                        setColorRed(other);
                        rightRotate(other);
                        other = parent.right;
                    }
                    /*node节点的兄弟节点是黑色，且兄弟节点的右孩子是红色，左孩子是任意颜色*/
                    setColor(other, getColor(parent));
                    setColorBlack(parent);
                    setColorBlack(other.right);
                    leftRotate(parent);
                    node = this.rootNode;
                    break;
                }
            } else {
                other = parent.left;
                if (isRed(other)) {
                    setColorBlack(other);
                    setColorRed(parent);
                    rightRotate(parent);
                    other = parent.left;
                }
 
                if ((null == other.left || isBlack(other.left)) &&
                        (null == other.right || isBlack(other.right))) {
                    setColorRed(other);
                    node = parent;
                    parent = getParent(node);
                } else {
                    if (null == other.left || isBlack(other.left)) {
                        setColorBlack(other.right);
                        setColorRed(other);
                        leftRotate(other);
                        other = parent.left;
                    }
 
                    setColor(other, getColor(parent));
                    setColorBlack(parent);
                    setColorBlack(other.left);
                    rightRotate(parent);
                    node = this.rootNode;
                    break;
                }
            }
        }
        if (node != null) {
            setColorBlack(node);
        }
    }
```

























































































































## HashMap

https://blog.csdn.net/crpxnmmafq/article/details/75331318?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162558865716780366574289%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162558865716780366574289&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-11-75331318.pc_search_result_control_group&utm_term=Java8+HashMap&spm=1018.2226.3001.4187

### 内部结构

JDK1.8 数组+链表红黑树

![image-20210727004842218](数据结构.assets/image-20210727004842218.png)

### 插入原理(put)

1. 判断数组是否为空，为空进行初始化;
2. 不为空，计算 k 的 hash 值，通过(n - 1) & hash计算应当存放在数组中的下标 index;
3. 查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；
4. 存在数据，说明发生了hash冲突(存在二个节点key的hash值一样), 继续判断key是否相等，相等，用新的value替换原数据(onlyIfAbsent为false)；
5. 如果不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中；(如果当前节点是树型节点证明当前已经是红黑树了)
6. 如果不是树型节点，创建普通Node加入链表中；判断链表长度是否大于 8并且数组长度大于64， 大于的话链表转换为红黑树；
7. 插入完成之后判断当前节点数是否大于阈值，如果大于开始扩容为原数组的二倍。



![image-20210727004923422](数据结构.assets/image-20210727004923422.png)

![image-20210727092932153](数据结构.assets/image-20210727092932153.png)

### HashMap怎么设定初始容量大小

一般如果`new HashMap()` 不传值，默认大小是16，负载因子是0.75， 

如果自己传入初始大小k，初始化大小为 大于k的 2的整数次方，例如如果传10，大小为16

```java
/**     * Returns a power of two size for the given target capacity.     */    static final int tableSizeFor(int cap) {        int n = cap - 1;        n |= n >>> 1;        n |= n >>> 2;        n |= n >>> 4;        n |= n >>> 8;        n |= n >>> 16;        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;    }
```



>补充说明：下图是详细过程，算法就是让初始二进制右移1，2，4，8，16位，分别与自己位或，把高位第一个为1的数通过不断右移，把高位为1的后面全变为1，最后再进行+1操作，111111 + 1 = 1000000 = 2^62   （符合大于50并且是2的整数次幂 ）
>![image-20210727005353532](数据结构.assets/image-20210727005353532.png)
>
>



### HashMap的哈希函数怎么设计的

https://blog.csdn.net/zhengwangzw/article/details/104889549?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162731499816780264041105%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162731499816780264041105&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-104889549.pc_search_result_before_js&utm_term=HashMap&spm=1018.2226.3001.4187

hash函数是先拿到 key 的hashcode，是一个32位的int值，然后让hashcode的高16位和低16位进行异或操作。

```java
/**     * Computes key.hashCode() and spreads (XORs) higher bits of hash     * to lower.  Because the table uses power-of-two masking, sets of     * hashes that vary only in bits above the current mask will     * always collide. (Among known examples are sets of Float keys     * holding consecutive whole numbers in small tables.)  So we     * apply a transform that spreads the impact of higher bits     * downward. There is a tradeoff between speed, utility, and     * quality of bit-spreading. Because many common sets of hashes     * are already reasonably distributed (so don't benefit from     * spreading), and because we use trees to handle large sets of     * collisions in bins, we just XOR some shifted bits in the     * cheapest possible way to reduce systematic lossage, as well as     * to incorporate impact of the highest bits that would otherwise     * never be used in index calculations because of table bounds.     */    static final int hash(Object key) {        int h;        // 1. 允许key=null hash=0        //2. ^按位异或 hash的高16位和低16位异或        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);    }
```



#### 为什么这么设计吗？

扰动函数, 原因有两点

1. 一定要尽可能降低hash碰撞，越分散越好；
2. 算法一定要尽可能高效，因为这是高频操作, 因此采用位运算；

#### 为什么采用hashcode的高16位和低16位异或能降低hash碰撞？hash函数能不能直接用key的hashcode？

因为key.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值。int值范围为**-2147483648~2147483647**，前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。

但问题是一个40亿长度的数组，内存是放不下的。如果HashMap数组的初始大小才16，用之前需要对数组的长度取模运算，得到的余数才能用来访问数组下标

源码中模运算就是把散列值和数组长度-1做一个"与"操作，位运算比取余%运算要快。

```C
bucketIndex = indexFor(hash, table.length);static int indexFor(int h, int length) {     return h & (length-1);}
```

这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为这样（数组长度-1）正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。

```
  10100101 11000100 00100101& 00000000 00000000 00001111----------------------------------  00000000 00000000 00000101    //高位全部归零，只保留末四位
```

但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，如果正好让最后几个低位呈现规律性重复，就无比蛋疼。这时候“扰动函数”的价值就体现出来了

![image-20210727010300685](数据结构.assets/image-20210727010300685.png)

右移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。

另外Java1.8相比1.7做了调整，1.7做了四次移位和四次异或，但明显Java 8觉得扰动做一次就够了，做4次的话，多了可能边际效用也不大，所谓为了效率考虑就改成一次了。

```javastatic int hash(int h) {
static int hash(int h) {    h ^= (h >>> 20) ^ (h >>> 12);    return h ^ (h >>> 7) ^ (h >>> 4);}
```

### 1.8还有有哪些优化吗？为什么这么优化?

#### 数组+链表改成了数组+链表或红黑树；

1. 防止发生hash冲突，链表长度过长，将时间复杂度由`O(n)`降为`O(logn)`;

#### 链表的插入方式从头插法改成了尾插法，简单说就是插入时，

1. 如果数组位置上已经有元素，

   1. 1.7将新元素放到数组中，原始节点作为新节点的后继节点，
   2. 1.8遍历链表，将元素放置到链表的最后；

2. 因为1.7头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；

   1. A线程在插入节点B，B线程也在插入，遇到容量不够开始扩容，重新hash，放置元素，

   2. 采用头插法，后遍历到的B节点放入了头部，这样形成了环，如下图所示：

   3. <img src="数据结构.assets/image-20210727010702272.png" alt="image-20210727010702272" style="zoom:50%;" />

   4. 1.7的扩容调用transfer代码，如下所示：

   5. ```java
      void transfer(Entry[] newTable, boolean rehash) {  int newCapacity = newTable.length;  for (Entry<K,V> e : table) {    while(null != e) {      Entry<K,V> next = e.next;      if (rehash) {        e.hash = null == e.key ? 0 : hash(e.key);      }      int i = indexFor(e.hash, newCapacity);      e.next = newTable[i]; //A线程如果执行到这一行挂起，B线程开始进行扩容      newTable[i] = e;      e = next;    }  }}
      ```

#### 扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小；

1. 扩容的时候为什么1.8 不用重新hash就可以直接定位原节点在新数据的位置呢?
   1. 这是由于扩容是扩大为原数组大小的2倍，用于计算数组位置的掩码仅仅只是高位多了一个1，怎么理解呢？
   2. 扩容前长度为16，用于计算(n-1) & hash 的二进制n-1为0000 1111，扩容为32后的二进制就高位多了1，为0001 1111。
   3. 因为是& 运算，1和任何数 & 都是它本身，那就分二种情况，如下图：原数据hashcode高位第4位为0和高位为1的情况；
   4. 第四位高位为0，重新hash数值不变，第四位为1，重新hash数值比原来大16（旧数组的容量）
   5. ![image-20210727011120677](数据结构.assets/image-20210727011120677.png)

#### 在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容；

### HashMap是线程安全的吗？

不是，

在多线程环境下，1.7 会产生死循环、数据丢失、数据覆盖的问题，

1.8 中会有数据覆盖的问题，

以1.8为例，当A线程判断index位置为空后正好挂起，B线程开始往index位置的写入节点数据，这时A线程恢复现场，执行赋值操作，就把A线程的数据给覆盖了；

还有++size这个地方也会造成多线程同时扩容等问题。

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {  Node<K,V>[] tab; Node<K,V> p; int n, i;  if ((tab = table) == null || (n = tab.length) == 0)    n = (tab = resize()).length;  if ((p = tab[i = (n - 1) & hash]) == null)  //多线程执行到这里    tab[i] = newNode(hash, key, value, null);  else {    Node<K,V> e; K k;    if (p.hash == hash &&        ((k = p.key) == key || (key != null && key.equals(k))))      e = p;    else if (p instanceof TreeNode) // 这里很重要      e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);    else {      for (int binCount = 0; ; ++binCount) {        if ((e = p.next) == null) {          p.next = newNode(hash, key, value, null);          if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st            treeifyBin(tab, hash);          break;        }        if (e.hash == hash &&            ((k = e.key) == key || (key != null && key.equals(k))))          break;        p = e;      }    }    if (e != null) { // existing mapping for key      V oldValue = e.value;      if (!onlyIfAbsent || oldValue == null)        e.value = value;      afterNodeAccess(e);      return oldValue;    }  }  ++modCount;  if (++size > threshold) // 多个线程走到这，可能重复resize()    resize();  afterNodeInsertion(evict);  return null;}
```

### 怎么解决HashMap线程不安全的问题

Java中有HashTable、Collections.synchronizedMap、以及ConcurrentHashMap可以实现线程安全的Map。

HashTable是直接在操作方法上加synchronized关键字，锁住整个数组，粒度比较大，

Collections.synchronizedMap是使用Collections集合工具的内部类，通过传入Map封装出一个SynchronizedMap对象，内部定义了一个对象锁，方法内通过对象锁实现；

ConcurrentHashMap使用分段锁，降低了锁粒度，让并发度大大提高。

### ConcurrentHashMap的分段锁的实现原理?

ConcurrentHashMap成员变量使用volatile 修饰，免除了指令重排序，同时保证内存可见性，另外使用CAS操作和synchronized结合实现赋值操作，多线程操作只会锁住当前操作索引的节点。

如下图，线程A锁住A节点所在链表，线程B锁住B节点所在链表，操作互不干涉。
![image-20210727082618482](数据结构.assets/image-20210727082618482.png)



### 链表转红黑树是链表长度达到阈值，这个阈值是多少

阈值是8，红黑树转链表阈值为6

#### 为什么是8，不是16，32甚至是7 ？又为什么红黑树转链表的阈值是6，不是8了呢？

因为经过计算，在hash函数设计合理的情况下，发生hash碰撞8次的几率为百万分之6，概率说话。。因为8够用了，

至于为什么转回来是6，因为如果hash碰撞次数在8附近徘徊，会一直发生链表和红黑树的互相转化，为了预防这种情况的发生。



### HashMap源码分析

#### hashmap的13 个成员变量

```
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;-> 数组默认初始容量：16static final int MAXIMUM_CAPACITY = 1 << 30;-> 数组最大容量2 ^ 30 次方static final float DEFAULT_LOAD_FACTOR = 0.75f;-> 默认负载因子的大小：0.75static final int MIN_TREEIFY_CAPACITY = 64;-> 树形最小容量：哈希表的最小树形化容量,超过此值允许表中桶转化成红黑树static final int TREEIFY_THRESHOLD = 8;-> 树形阈值：当链表长度达到8时，将链表转化为红黑树static final int UNTREEIFY_THRESHOLD = 6;-> 树形阈值：当链表长度小于6时，将红黑树转化为链表transient int modCount; -> hashmap修改次数int threshold; -> 可存储key-value 键值对的临界值 需要扩充时;值 = 容量 * 加载因子transient int size; 已存储key-value 键值对数量final float loadFactor; -> 负载因子transient Set< Map.Entry< K,V >> entrySet; -> 缓存的键值对集合transient Node< K,V>[] table; -> 链表数组（用于存储hashmap的数据）
```

#### 构造方法

```java
    /**     * 默认无参构造方法：     * 初始容量16     * 负载因子0.75     */public HashMap() {        this.loadFactor = DEFAULT_LOAD_FACTOR;     }    /**     * 参数为初始容量     */public HashMap(int initialCapacity) {        this(initialCapacity, DEFAULT_LOAD_FACTOR); //调用HashMap(int initialCapacity, float loadFactor) 构造方法    }    /**     * 参数为初始容量 和 负载因子     */public HashMap(int initialCapacity, float loadFactor) {        if (initialCapacity < 0)            throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);     if (initialCapacity > MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        if (loadFactor <= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException("Illegal load factor: " + loadFactor);        this.loadFactor = loadFactor;        this.threshold = tableSizeFor(initialCapacity);    }    /**     * 设置可存储的 key-value 键值对最大值     * 返回值为传入参数最接近的且大于等于的2的n次方     * 传入参数 3 -> 4     * 传入参数 5 -> 8     * 传入参数 32 -> 32     * 传入参数 33 -> 64     */    static final int tableSizeFor(int cap) {        int n = cap - 1;        n |= n >>> 1;        n |= n >>> 2;        n |= n >>> 4;        n |= n >>> 8;        n |= n >>> 16;        return (n < 0) ? 1 : (n >= 1 << 30) ? 1 << 30 : n + 1;    }    /*     * 构造一个新的 HashMap与指定的相同的映射 Map 。     */    public HashMap(Map<? extends K, ? extends V> m) {       this.loadFactor = DEFAULT_LOAD_FACTOR;       putMapEntries(m, false);   }   // 具体实现将map 内元素遍历插入hash表中    final void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {        int s = m.size();        if (s > 0) {            if (table == null) { // pre-size                float ft = ((float)s / loadFactor) + 1.0F;// ft代表 在默认负载因子下，该hashmap的容量                int t = ((ft < (float)MAXIMUM_CAPACITY) ?                         (int)ft : MAXIMUM_CAPACITY);// 相当于执行 (int)Math.floor(ft);                if (t > threshold)                    threshold = tableSizeFor(t);// 重新设置临界值            }            else if (s > threshold)                resize();            // 一次将元素插入 后面详细讲解            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {                K key = e.getKey();                V value = e.getValue();                putVal(hash(key), key, value, false,evict);            }        }    }
```



#### Node<K,V> 存储结构

```java
// 用于存储key-value键值// Map.Entry仅定义一些方法 因此不列出详细代码static class Node<K,V> implements Map.Entry<K,V> {        final int hash;        final K key;        V value;        Node<K,V> next; // 保存下一个节点地址        Node(int hash, K key, V value, Node<K,V> next) {            this.hash = hash;            this.key = key;            this.value = value;            this.next = next;        }        public final K getKey()        { return key; }        public final V getValue()      { return value; }        public final String toString() { return key + "=" + value; }        public final int hashCode() {            return Objects.hashCode(key) ^ Objects.hashCode(value);        }        public final V setValue(V newValue) {            V oldValue = value;            value = newValue;            return oldValue;        }        public final boolean equals(Object o) {            // 此处进行的地址的比较            if (o == this)                return true;            // 此处调用equal方法，若该类重写equal方法则调用重写后的equal方法            if (o instanceof Map.Entry) {                Map.Entry<?,?> e = (Map.Entry<?,?>)o;                if (Objects.equals(key, e.getKey()) &&                    Objects.equals(value, e.getValue()))                    return true;            }            return false;        }    }
```



#### Put

```java
    /**     * K - key（键） V - Value （值）     */public V put(K key, V value) {        return putVal(hash(key), key, value, false, true);    }    /**     * hashcode 计算方式     * 若未重写hashcode方法 则调用object的hashcode方法     * 涉及数据结构红黑树 再此不详细讲解     * 当容量达到64 且 单个位置链表长度达到8 链表转化红黑树     * 若 单个位置链表长度减小到6 将红黑树转化会链表     */static final int hash(Object key) {        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);    }     /**     * 插入key-value 键值对具体实现     */     final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) {        Node<K,V>[] tab; Node<K,V> p; int n, i;        // 判断 若hashmap内没有值 则重构hashmap        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        // 若指定位置hashcode 未被占用 则直接将该键值对插入        if ((p = tab[i = (n - 1) & hash]) == null)            tab[i] = newNode(hash, key, value, null);        // 发生冲突时 解决方法        else {            Node<K,V> e; K k;            // 若地址相同 直接新值替换旧值            if (p.hash == hash &&                ((k = p.key) == key || (key != null && key.equals(k))))                e = p;            // 若冲突位置已经是红黑树作为存储结构 则将该键值对插入红黑树中            else if (p instanceof TreeNode)                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);            // 冲突位置不为红黑树 将该节点插入链表            else {                // 死循环                for (int binCount = 0; ; ++binCount) {                    if ((e = p.next) == null) {                        p.next = newNode(hash, key, value, null);                        // 若此时链表内长度大于等于7 将链表转化为红黑树 并将节点插入                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st                            treeifyBin(tab, hash);                        break;                    }                    // 若带插入数据与存储数据有重复时 结束                    if (e.hash == hash &&                        ((k = e.key) == key || (key != null && key.equals(k))))                        break;                    p = e;                }            }            if (e != null) { // existing mapping for key                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                afterNodeAccess(e);                return oldValue;            }        }        ++modCount;        // 若容量不足 则扩容        if (++size > threshold)            resize();        afterNodeInsertion(evict);        return null;    }    /**     * 调整底层用于存储数据的hashmap底层数组长度     * 优化操作效率 -> 每次扩容 扩大为原来的2倍     */    final Node<K,V>[] resize() {        Node<K,V>[] oldTab = table;        int oldCap = (oldTab == null) ? 0 : oldTab.length;        int oldThr = threshold;        int newCap, newThr = 0;        // 是否可以扩容        if (oldCap > 0) {            // 若已经最大 没办法 让他冲突去吧            if (oldCap >= MAXIMUM_CAPACITY) {                threshold = Integer.MAX_VALUE;                return oldTab;            }            // 将容量翻倍            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)                newThr = oldThr << 1; // double threshold        }        // 如果旧容量为 0 ，并且旧阈值>0，说明之前创建了哈希表但没有添加元素，初始化容量等于阈值        else if (oldThr > 0) // initial capacity was placed in threshold            newCap = oldThr;        else {               // zero initial threshold signifies using defaults            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        }         // 如果新的阈值为 0 ，就得用 新容量*加载因子 重计算一次        if (newThr == 0) {            float ft = (float)newCap * loadFactor;            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?(int)ft : Integer.MAX_VALUE);        }        threshold = newThr;        @SuppressWarnings({"rawtypes","unchecked"})        // 将底层链表数组 数据复制已经调整过大小的新链表数据            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];        table = newTab;        if (oldTab != null) {            for (int j = 0; j < oldCap; ++j) {                Node<K,V> e;                if ((e = oldTab[j]) != null) {                    oldTab[j] = null;                    if (e.next == null)                        newTab[e.hash & (newCap - 1)] = e;                    else if (e instanceof TreeNode)                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);                    else { // preserve order                        Node<K,V> loHead = null, loTail = null;                        Node<K,V> hiHead = null, hiTail = null;                        Node<K,V> next;                        do {                            next = e.next;                            if ((e.hash & oldCap) == 0) {                                if (loTail == null)                                    loHead = e;                                else                                    loTail.next = e;                                loTail = e;                            }                            else {                                if (hiTail == null)                                    hiHead = e;                                else                                    hiTail.next = e;                                hiTail = e;                            }                        } while ((e = next) != null);                        if (loTail != null) {                            loTail.next = null;                            newTab[j] = loHead;                        }                        if (hiTail != null) {                            hiTail.next = null;                            newTab[j + oldCap] = hiHead;                        }                    }                }            }        }        return newTab;    }
```



#### Get

```java
    /**     * 传入key值返回value值     * 若不存在则返回null     */      public V get(Object key) {        Node<K,V> e;        return (e = getNode(hash(key), key)) == null ? null : e.value;    }    // 具体实现get-value 方法     final Node<K,V> getNode(int hash, Object key) {        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;        // 若表不为空且长度不为0 且指定位置hash表内有元素        if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) {        // 若key值相同 返回该节点            if (first.hash == hash && // always check first node((k = first.key) == key || (key != null && key.equals(k))))                return first;            // 若该节点有下一个节点 且该节点属于红黑树节点            // 按照红黑树高效查找            if ((e = first.next) != null) {                if (first instanceof TreeNode)                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);                // 直到下一个节点为空 循环 对比key值                do {                    if (e.hash == hash &&                        ((k = e.key) == key || (key != null && key.equals(k))))                        return e;                } while ((e = e.next) != null);            }        }        // 若数组不存在hash算法的值 返回null        return null;    }
```



#### Remove

```java
    /**     * 传入key 移除该key-value键值对     * 若不存在 key 返回null     */    public V remove(Object key) {        Node<K,V> e;        return (e = removeNode(hash(key), key, null, false, true)) == null ?            null : e.value;    }    // 具体实现 remove - key 方法    final Node<K,V> removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) {        Node<K,V>[] tab; Node<K,V> p; int n, index;         // 若表不为空且长度不为0 且指定位置hash表内有元素        if ((tab = table) != null && (n = tab.length) > 0 && (p = tab[index = (n - 1) & hash]) != null) {            Node<K,V> node = null, e; K k; V v;            // 若key值相同 保留该节点            if (p.hash == hash &&                ((k = p.key) == key || (key != null && key.equals(k))))                node = p;            else if ((e = p.next) != null) {                // 若该节点属于红黑树 按照红黑树查找方式                 if (p instanceof TreeNode)                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);                else {                    // 循环链表直到链表为空 依次对比key 若相同 保留该节点                    do {                        if (e.hash == hash &&                            ((k = e.key) == key ||                             (key != null && key.equals(k)))) {                            node = e;                            break;                        }                        p = e;                    } while ((e = e.next) != null);                }            }            // 将该节点移除            if (node != null && (!matchValue || (v = node.value) == value || (value != null && value.equals(v)))) {                if (node instanceof TreeNode)                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);                else if (node == p)                    tab[index] = node.next;                else                    p.next = node.next;                ++modCount;                --size;                afterNodeRemoval(node);                return node;            }        }        // 若数组不存在hash算法的值 返回null        return null;    }
```

#### putAll

```java
    /**     *  参数为map 要求key-value      *  对应的泛型要求 K -key（本类或子类）V -value（本类或子类）     */    public void putAll(Map<? extends K, ? extends V> m) {        putMapEntries(m, true);    }    // 具体插入实现    final void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {        int s = m.size();        if (s > 0) {            // 若表为空 加载一些成员变量            if (table == null) { // pre-size                float ft = ((float)s / loadFactor) + 1.0F;                int t = ((ft < (float)MAXIMUM_CAPACITY) ?                         (int)ft : MAXIMUM_CAPACITY);                if (t > threshold)                    threshold = tableSizeFor(t);            }            // 重新调整大小            else if (s > threshold)                resize();            // 依次遍历元素 插入数据            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {                K key = e.getKey();                V value = e.getValue();                putVal(hash(key), key, value, false, evict);            }        }    }
```













### HashMap内部节点是有序的吗？

是无序的，根据hash值随机插入

LinkedHashMap 和 TreeMap是有序的

### LinkedHashMap怎么实现有序的？

 LinkedHashMap内部维护了一个单链表，有头尾节点，同时LinkedHashMap节点Entry内部除了继承HashMap的Node属性，还有before 和 after用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序。

```java
/** * The head (eldest) of the doubly linked list.*/transient LinkedHashMap.Entry<K,V> head;/**  * The tail (youngest) of the doubly linked list.*/transient LinkedHashMap.Entry<K,V> tail;//链接新加入的p节点到链表后端private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {  LinkedHashMap.Entry<K,V> last = tail;  tail = p;  if (last == null)    head = p;  else {    p.before = last;    last.after = p;  }}//LinkedHashMap的节点类static class Entry<K,V> extends HashMap.Node<K,V> {  Entry<K,V> before, after;  Entry(int hash, K key, V value, Node<K,V> next) {    super(hash, key, value, next);  }}
```

### TreeMap怎么实现有序的？

TreeMap是按照Key的自然顺序或者Comprator的顺序进行排序，内部是通过红黑树来实现。

所以要么key所属的类实现Comparable接口，或者自定义一个实现了Comparator接口的比较器，传给TreeMap用于key的比较



### HashMap总结

- hashmap基于哈希表的 map接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。

- 与hashtable区别是hashmap允许使用null作为key值，且线程不安全，hashtable不允许null作为key值线程安全，可以使用Collections.synchronizedMap使hashmap线程安全,

- 在JDK1.5后建议使用ConcurrentHashMap,ConcurrentHashMap采用锁分段机制，hashtable是一个线程访问时，其他线程无法访问，ConcurrentHashMap是一个线程访问某个指定数组的某一个下标，该下标所在段不允许其他线程访问，其他线程仍可访问ConcurrentHashMap的其他下标。

- hashmap底层数据结构是基于数组和链表（红黑树 ）来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。

  - 通过key值计算hash码值，将其传递进数组，若hash码值冲突则采用链表连接，
  - 若该hashmap容量大于64且该链表长度大于8则将该链表转化为红黑树，
  - 若链表长度减少到6时候，则将红黑树转化回链表

- hashmap每次扩容扩大为原来的两倍，扩容后原来的元素要么还在原来的位置, 要么移动到原来的位置+原来数组的长度的位置

  - ```java
    /**     * Initializes or doubles table size.  If null, allocates in     * accord with initial capacity target held in field threshold.     * Otherwise, because we are using power-of-two expansion, the     * elements from each bin must either stay at same index, or move     * with a power of two offset in the new table.     *     * @return the table     */    final Node<K,V>[] resize() {        Node<K,V>[] oldTab = table;        int oldCap = (oldTab == null) ? 0 : oldTab.length;        int oldThr = threshold;        int newCap, newThr = 0;        if (oldCap > 0) {            if (oldCap >= MAXIMUM_CAPACITY) {                threshold = Integer.MAX_VALUE;                return oldTab;            }            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&                     oldCap >= DEFAULT_INITIAL_CAPACITY)                newThr = oldThr << 1; // double threshold        }        else if (oldThr > 0) // initial capacity was placed in threshold            newCap = oldThr;        else {               // zero initial threshold signifies using defaults            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        }        if (newThr == 0) {            float ft = (float)newCap * loadFactor;            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?                      (int)ft : Integer.MAX_VALUE);        }        threshold = newThr;        @SuppressWarnings({"rawtypes","unchecked"})        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];        table = newTab;        if (oldTab != null) {            for (int j = 0; j < oldCap; ++j) {                Node<K,V> e;                if ((e = oldTab[j]) != null) {                    oldTab[j] = null;                    if (e.next == null)                        newTab[e.hash & (newCap - 1)] = e;                    else if (e instanceof TreeNode)                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);                    else { // preserve order                        Node<K,V> loHead = null, loTail = null;                        Node<K,V> hiHead = null, hiTail = null;                        Node<K,V> next;                        do {                            next = e.next;                            if ((e.hash & oldCap) == 0) {                                if (loTail == null)                                    loHead = e;                                else                                    loTail.next = e;                                loTail = e;                            }                            else {                                if (hiTail == null)                                    hiHead = e;                                else                                    hiTail.next = e;                                hiTail = e;                            }                        } while ((e = next) != null);                        if (loTail != null) {                            loTail.next = null;                            newTab[j] = loHead;                        }                        if (hiTail != null) {                            hiTail.next = null;                            newTab[j + oldCap] = hiHead;                        }                    }                }            }        }        return newTab;    }
    ```

  - 





### CAS 的实现以及synchronized的实现原理吗？



## LinkedHashMap



## TreeMap



## ConcurrentHashMap

















































## B B+ B*树

### B树

B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个）

- 排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
- 子节点数：非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；
- 关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);
- 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;

![image-20210727001118341](数据结构.assets/image-20210727001118341.png)

- B树查询流程
  - 如上图我要从上图中找到E字母，查找流程如下
  - 获取根节点的关键字进行比较，当前根节点关键字为M，E<M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；
  - 拿到关键字D和G，D<E<G 所以直接找到D和G中间的节点；
  - 拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；

- B树插入节点流程
  - （1）节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须<=5-1（这里关键字数>4就要进行节点拆分）；
  - （2）排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;

- B树节点删除
  - （1）节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数<2就要进行节点合并）；
  - （2）满足节点本身比左边节点大，比右边节点小的排序规则;
  - （3）关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；

B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;

### B+树

B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。

- B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；
- B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；
- B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。
- 非叶子节点的子节点数=关键字数

![image-20210727001602614](数据结构.assets/image-20210727001602614.png)

- B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；

- B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

- B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
- B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。

### B*树

B*树是B+树的变种

- （1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b*树的初始化个数为（cei(2/3*m)）
- （2）B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；

在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；

### B树总结

1、相同思想和策略
从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；

2、不同的方式的磁盘空间利用
不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；