# 数据结构

 [二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)的概念？[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)又是什么，[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)和其他平衡树的区别在哪 

1. [平衡二叉树](https://www.nowcoder.com/jump/super-jump/word?word=平衡二叉树)是什么？用普通二叉搜索树不行吗？ [红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)和平衡树的区别 
2. 说一下对于树的理解
3. [二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)，二叉查找树，[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)
4. 堆排 快排 
5. LRU 



## 二叉查找树

对于数中的每个结点node, 

- node.left.val<node.val 
- node.right.val>node.val

二叉查找树的平均深度是O(logN)

包括的操作

1. contains
2. findMin findMax
   1. 最左子节点, 最右子节点
   2. 递归迭代两种方法
3. insert
4. remove
   1. 叶子结点直接删除
   2. 待删除结点有一个子树,  将待删除结点的父节点连上这个子树
   3. 有两个子树, 
      1. 需要找到左子树的最右子节点, 或者右子树的最左子节点代替待删除结点, 并且在子树中删除这个代替的结点

```java

package com.ccq.Binary_Search_Tree;

import java.util.ArrayDeque;
import java.util.Deque;

/**
 * @author Chaoqun Cheng
 * @date 2021-08-2021/8/4-0:23
 */

public class BinarySearchTree<E extends Comparable<E>> {
    /**
     * 结点类
     */
    private class Node{
        public E e;
        public Node left, right;
        public Node(E _e){
            this.e = _e;
            left = null;
            right = null;
        }
    }
    private Node root;
    private int size;
    public BinarySearchTree(){
        root = null;
        size = 0;
    }

    public BinarySearchTree(Node node){
        root = node;
        size++;
    }

    public int size(){
        return size;
    }

    public boolean isEmpty(){
        return size==0;
    }

    //===================================插入元素======================================

    /**
     * 向node为根元素的二分搜索树中插入元素
     * 如果存在就更新值
     * @param node
     * @param e
     * @return
     */
    private Node add(Node node, E e){
        if(node==null){
            size++;
            return new Node(e);
        }
        if(e.compareTo(node.e)<0){
            node.left = add(node.left, e);
            return node;
        }else if(e.compareTo(node.e)>0){
            node.right = add(node.right, e);
            return node;
        }else{
            node.e = e;
        }
        return node;
    }

    /**
     * 向二分搜索树中添加元素
     * @param e
     */
    public void add(E e){
        if(root==null){
            root = new Node(e);
        }
        add(root, e);
    }

    //===================================查找元素======================================

    /**
     * 判断以node为根元素的二分搜索树是否包含某个元素
     * @param node
     * @param e
     * @return
     */
    private boolean contains(Node node, E e){
        if(node==null){
            return false;
        }
        if(e.compareTo(node.e)<0){
            return contains(node.left, e);
        }else if(e.compareTo(node.e)>0){
            return contains(node.right, e);
        }else{
            return true;
        }
    }

    /**
     * 判断二分搜索树是否包含某个元素
     * @param e
     * @return
     */
    public boolean contains(E e){
        return contains(root, e);
    }

    private void checkEmpty(){
        if(isEmpty()){
            throw new IllegalArgumentException("BinarySearchTree is empty !");
        }
    }

    /**
     * 查找以node为根节点二分搜索树的最小节点
     * @param node
     * @return
     */
    private Node findMin(Node node){
        checkEmpty();
        if(node==null){
            return null;
        }
        if(node.left==null){
            return node;
        }
        return findMin(node.left);
    }

    /**
     * 查找二分搜索树的最小值
     * @return
     */
    public E findMin(){
        checkEmpty();
        Node min = findMin(root);
        return min==null?null:min.e;
    }

    /**
     * 查找以node为根节点二分搜索树的最大节点
     * @param node
     * @return
     */
    private Node findMax(Node node){
        checkEmpty();
        if(node==null){
            return null;
        }
        if(node.right==null){
            return node;
        }
        return findMin(node.right);
    }

    /**
     * 查找二分搜索树的最大值
     * @return
     */
    public E findMax(){
        checkEmpty();
        Node max = findMax(root);
        return max==null?null:max.e;
    }


    //===================================遍历二叉树======================================
    /**
     * 前序遍历二分搜索树
     */
    public void preOrder(){
        preOrder(root);
    }

    /**
     * 前序遍历以node为根节点的二分搜索树
     * 深度优先遍历，递归实现
     * @param node
     */
    private void preOrder(Node node){
        if(node == null){
            return;
        }
        System.out.println(node.e);
        preOrder(node.left);
        preOrder(node.right);
    }

    public void inOrder(){
        inOrder(root);
    }

    private void inOrder(Node node){
        if(node == null){
            return;
        }
        inOrder(node.left);
        System.out.println(node.e);
        inOrder(node.right);
    }

    public void postOrder(){
        postOrder(root);
    }

    private void postOrder(Node node){
        if(node == null){
            return;
        }
        postOrder(node.left);
        postOrder(node.right);
        System.out.println(node.e);
    }

    /**
     * 前序遍历二分搜索树
     * 深度优先遍历，非递归实现，利用栈结构
     */
    public void preOrderByStack(){
        if(root==null){
            return;
        }
        Deque<Node> stack = new ArrayDeque<>();
        stack.push(root);
        while(!stack.isEmpty()){
            Node curNode = stack.pop();
            System.out.println(curNode.e);
            if(curNode.right!=null){
                stack.push(curNode.right);
            }
            if(curNode.left!=null){
                stack.push(curNode.left);
            }
        }
    }

    /**
     * BFS
     */
    public void levelOrder(){
        if(root==null){
            return;
        }
        Deque<Node> queue = new ArrayDeque<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            Node cur = queue.poll();
            System.out.println(cur);
            if(cur.left!=null){
                queue.offer(cur.left);
            }
            if(cur.right!=null){
                queue.offer(cur.right);
            }
        }
    }

    //===================================删除二叉树的结点======================================

    /**
     * 删除以node为根的二分搜索树的最大节点
     * @param node
     * @return
     */
    private Node removeMax(Node node){
        if(node==null){
            return null;
        }
        if(node.right==null){
            Node leftNode = node.left;
            node.left = null;
            size--;
            return leftNode;
        }
        node.right = removeMax(node.right);
        return node;
    }

    /**
     * 删除二分搜索树的最大值
     * @return
     */
    public E removeMax(){
        E max = findMax();
        removeMax(root);
        return max;
    }

    /**
     * 删除以node为根的二分搜索树的最小节点
     * @param node
     * @return
     */
    private Node removeMin(Node node){
        if(node==null){
            return null;
        }
        if(node.left==null){
            Node rightNode = node.right;
            node.right = null;
            size--;
            return rightNode;
        }
        node.left = removeMin(node.left);
        return node;
    }

    /**
     * 删除二分搜索树的最小值
     * @return
     */
    public E removeMin(){
        E min = findMin();
        removeMin(root);
        return min;
    }

    public void remove(E e){
        root = remove(root,e);
    }

    private Node remove(Node node, E e){
        if(node==null){
            return null;
        }
        if(e.compareTo(node.e)<0){
            node.left = remove(node.left, e);
            return node;
        }else if(e.compareTo(node.e)>0){
            node.right = remove(node.right, e);
            return node;
        }else{
            if(node.right==null){
                Node leftNode = node.left;
                node.left = null;
                size--;
                return leftNode;
            }else if(node.left==null){
                Node rightNode = node.right;
                node.right = null;
                size--;
                return rightNode;
            }else{
                //删除后用前驱节点替代该位置(前驱节点即待删除节点左子树中的最大节点)
                Node successor = findMax(node.left);
                //除前驱节点，并让待删除节点的左子树成为前驱节点的左子树
                successor.left = removeMax(node.left);
                // 让待删除节点的右子树成为前驱节点的右子树
                successor.right = node.right;
                // 将待删除节点的左、右子节点置为空
                node.left = node.right = null;
                return successor;
            }
        }
    }
    @Override
    public String toString() {
        StringBuilder result = new StringBuilder();
        generateBSTString(root,0,result);
        return result.toString();
    }

    /**
     * 生成二分搜索树的字符
     */
    private void generateBSTString(Node node, int depth, StringBuilder result) {
        if (node == null) {
            result.append(generateBSTString(depth)+"null\n");
            return;
        }
        result.append(generateBSTString(depth)+node.e+"\n");
        generateBSTString(node.left,depth+1,result);
        generateBSTString(node.right,depth+1,result);
    }

    /**
     * 生成表示深度的字符
     */
    private String generateBSTString(int depth) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < depth; i++) {
            result.append("--");
        }
        return result.toString();
    }
}

```



## AVL

### AVL树的定义

- 平衡因子 : 树中某结点其左子树的高度和右子树的高度之差
- AVL树中的任意一个结点, 其平衡因子的绝对值小于2
- AVL树是一种特殊的二叉搜索树 (BST树), 相对于数据极端情况下, 二叉搜索树会退化成为单链表, AVL树定义了旋转操作, 在平衡因子大于等于2时, AVL树会旋转来调整树的结构, 来重新满足平衡因子小于2

### AVL树不平衡的情况

`AVL树`大部分操作都和`BST树`相同, 只有在插入删除结点时, 有可能造成`AVL树`失去平衡, 而且只有那些在被插入/删除结点到根节点的路径上的结点有可能出现失衡, 因为只有那些结点的子树结构发生了变化

当插入新结点导致不平衡时, 我们需要找到距离新节点`最近`的不平衡结点为轴来转动`AVL树`来达到平衡

### 单旋转

![image-20210804092841650](数据结构.assets/image-20210804092841650.png)

![image-20210804092904127](数据结构.assets/image-20210804092904127.png)

![image-20210804092912962](数据结构.assets/image-20210804092912962.png)

![image-20210804092923893](数据结构.assets/image-20210804092923893.png)

![image-20210804093015574](数据结构.assets/image-20210804093015574.png)

![image-20210804093025531](数据结构.assets/image-20210804093025531.png)

### 双旋转

![image-20210804093134991](数据结构.assets/image-20210804093134991.png)



![image-20210804093317599](数据结构.assets/image-20210804093317599.png)

![image-20210804093348584](数据结构.assets/image-20210804093348584.png)

![image-20210804093452016](数据结构.assets/image-20210804093452016.png)

![image-20210804093510708](数据结构.assets/image-20210804093510708.png)

![image-20210804093523064](数据结构.assets/image-20210804093523064.png)

```java
package com.ccq.AVL_Tree;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

/** 二分查找树
 * @author Chaoqun Cheng
 * @date 2021-08-2021/8/4-0:00
 */

public class AVLTree<K extends Comparable<K>,V> {
    private class Node{
        public K key;
        public V value;
        public int height;
        public Node left, right;
        public Node(K _key, V _value){
            key = _key;
            value = _value;
            left = null;
            right = null;
            height = 1;
        }
    }

    private Node root;
    private int size;
    public AVLTree(){
        root = null;
        size = 0;
    }

    public boolean isEmpty(){
        return size==0;
    }
    public boolean contains(K key) {
        return getNode(root,key) != null;
    }

    public V get(K key) {
        Node node = getNode(root, key);
        return node != null ? node.value : null;
    }

    public void set(K key, V value) {
        Node node = getNode(root, key);
        if(node == null){
            throw new IllegalArgumentException("Set failed. key is not exists!");
        }
        node.value = value;
    }

    public int getSize() {
        return size;
    }

    /**
     * 根据key获取Node
     * @param node
     * @param key
     * @return
     */
    private Node getNode(Node node, K key){
        if(node==null){
            return null;
        }
        if(key.compareTo(node.key) == 0){
            return node;
        }else if(key.compareTo(node.key) < 0){
            return getNode(node.left,key);
        }else{
            return getNode(node.right,key);
        }
    }

    //=====================================AVL二叉树的平衡属性===================================
    /**
     * 获取某个节点的高度
     * @param node
     * @return
     */
    private int getHeight(Node node){
        if(node==null){
            return 0;
        }
        return node.height;
    }

    /**
     * 获取某个节点的平衡因子
     * @param node
     * @return
     */
    private int getBalanceFactor(Node node){
        if(node==null){
            return 0;
        }
        return getHeight(node.left)-getHeight(node.right);
    }

    /**
     * 查看AVL平衡二叉树是否是二分搜索树
     * 通过中序遍历得到二叉树的key的集合, 如果是升序的则是二分搜索树
     * @return
     */
    public boolean isBinarySearchTree(){
        List<K> keys = new ArrayList<>();
        inOrder(root, keys);
        for(int i=1; i<keys.size(); i++){
            if(keys.get(i-1).compareTo(keys.get(i))>0){
                return false;
            }
        }
        return true;
    }

    /**
     * 归查看以node为根节点的AVL平衡二叉树是否是平衡二叉树
     * @param node
     * @return
     */
    private boolean isBalanced(Node node){
        if(node==null){
            return true;
        }
        if(Math.abs(getBalanceFactor(node))>1){
            return false;
        }
        return isBalanced(node.left) && isBalanced(node.right);
    }

    /**
     * 查看AVL平衡二叉树是否是平衡二叉树
     * @return
     */
    public boolean isBalanced(){
        return isBalanced(root);
    }

    //=====================================AVL二叉树的旋转===================================

    /**右旋转操作
     // 对节点y进行向右旋转操作，返回旋转后新的根节点x
     //        y                              x
     //       / \                           /   \
     //      x   T4     向右旋转 (y)        z     y
     //     / \       - - - - - - - ->    / \   / \
     //    z   T3                       T1  T2 T3 T4
     //   / \
     // T1   T2
     * @return
     */
    private Node rightRotate(Node node){
        Node x = node.left;
        Node T3 = x.right;
        //右旋
        x.right = node;
        node.left = T3;
        //更新height
        updateHeight(node);
        updateHeight(x);
        return x;
    }

    /**左旋转操作
     // 对节点y进行向左旋转操作，返回旋转后新的根节点x
     //    y                             x
     //  /  \                          /   \
     // T1   x      向左旋转 (y)       y     z
     //     / \   - - - - - - - ->   / \   / \
     //   T2  z                     T1 T2 T3 T4
     //      / \
     //
     * @param node
     * @return
     */
    private Node leftRotate(Node node){
        Node x = node.right;
        Node T2 = x.left;
        //左旋转操作
        x.left = node;
        node.right = T2;
        //更新height
        updateHeight(node);
        updateHeight(x);
        return x;
    }

    //=====================================遍历AVL二叉树===================================
    /**
     * 中序遍历以node为根节点的AVL平衡二叉树 递归
     * @param node
     * @param keys
     */
    private void inOrder(Node node, List<K> keys){
        if(node==null){
            return;
        }
        inOrder(node.left, keys);
        keys.add(node.key);
        inOrder(node.right, keys);
    }

    /**
     * 中序遍历以node为根节点的AVL平衡二叉树 迭代
     * @param node
     * @param keys
     */
    private void inOrderByStack(Node node, List<K> keys){
        if(node==null){
            return;
        }
        Deque<Node> stack = new ArrayDeque<>();
        while(node!=null || !stack.isEmpty()){
            while(node!=null){
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            keys.add(node.key);
            node = node.right;
        }
    }


    //=====================================AVL二叉树的插入操作===================================

    /**
     * 旋转之后更新node的高度属性
     * @param node
     */
    private void updateHeight(Node node){
        node.height = Math.max(getHeight(node.left), getHeight(node.right))+1;
    }

    /**
     * 向node为根元素的AVL平衡二叉树中插入元素
     * @param node
     * @param key
     * @param value
     * @return
     */
    private Node add(Node node, K key, V value){
        //递归结束
        if(node==null){
            size++;
            return new Node(key,value);
        }
        //递归找到插入节点的位置插入节点, 存在就更新结点值
        if(key.compareTo(node.key)<0){
            node.left = add(node.left, key, value);
        }else if(key.compareTo(node.key)>0){
            node.right = add(node.right, key, value);
        }else{
            node.value = value;
        }
        //维护平衡
        return keepBalance(node);
    }

    /**
     * 向AVL平衡二叉树中插入元素
     * @param key
     * @param value
     */
    public void add(K key, V value){
        root = add(root, key, value);
    }

    /**
     * 维护node结点的平衡
     * @param node
     * @return
     */
    private Node keepBalance(Node node){
        if(node==null){
            return null;
        }
        //更新height
        updateHeight(node);
        /**========== 维护平衡 Start ==========*/
        //计算平衡因子
        int balanceFactor = getBalanceFactor(node);
        /**----------单旋转 LL RR -------------*/
        //LL左孩子节点的左侧产生不平衡 node.left.left.height>node.left.right.height
        if(balanceFactor>1 && getBalanceFactor(node.left)>=0){
            //右旋转
            return rightRotate(node);
        }
        //RR右孩子节点的右侧产生不平衡 node.right.right.height > node.right.left.height
        if(balanceFactor<-1 && getBalanceFactor(node.right)<=0){
            //左旋转
            return leftRotate(node);
        }
        /**----------双旋转 LR RL -------------*/
        //LR左孩子节点的右侧产生不平衡 node.left.right.height > node.left.left.height
        if(balanceFactor>1 && getBalanceFactor(node.left)<0){
            //node.left左旋 变成LL的情况
            node.left = leftRotate(node.left);
            //node.left左旋之后node右旋
            return rightRotate(node);
        }
        //RL右孩子节点的左侧产生不平衡
        if(balanceFactor<-1 && getBalanceFactor(node.right)>0){
            //node.right右旋变成RR
            node.right = rightRotate(node.right);
            //node.right右旋之后 node左旋
            return leftRotate(node);
        }
        /**========== 维护平衡 End ==========*/
        return node;

    }



    //=====================================AVL二叉树的查询操作===================================
    private void checkEmpty(){
        if(isEmpty()){
            throw new IllegalArgumentException("BinarySearchTree is empty !");
        }
    }
    /**
     * 查找AVL平衡二叉树的最小值
     * @return
     */
    public V minimum(){
        checkEmpty();
        return minimum(root).value;
    }

    /***
     * 查找以node为根节点AVL平衡二叉树的最小节点
     * @param node
     * @return
     */
    private Node minimum(Node node){
        checkEmpty();
        if(node.left==null){
            return node;
        }
        return minimum(node.left);
    }

    /**
     * 查找AVL平衡二叉树的最大值
     * @return
     */
    public V maxmize(){
        checkEmpty();
        return maxmize(root).value;
    }

    /***
     * 查找以node为根节点AVL平衡二叉树的最大节点
     * @param node
     * @return
     */
    private Node maxmize(Node node){
        checkEmpty();
        if(node.right==null){
            return node;
        }
        return maxmize(node.right);
    }

    //=====================================AVL二叉树的删除操作===================================

    /**
     * 删除以node为根的AVL平衡二叉树的最大节点
     * @param node
     * @return
     */
    private Node removeMax(Node node){
        if(node.right==null){
            Node leftNode  = node.left;
            node.left = null;
            size--;
            return leftNode;
        }
        node.right = removeMax(node.right);
        return node;
    }

    /**
     * 删除AVL平衡二叉树的最大值
     * @return
     */
    public V removeMax(){
        V maximum = maxmize();
        removeMax(root);
        return maximum;
    }

    /**
     * 删除以node为根的AVL平衡二叉树的最小节点
     * @param node
     * @return
     */
    private Node removeMin(Node node){
        if(node.left==null){
            Node rightNode  = node.right;
            node.right = null;
            size--;
            return rightNode;
        }
        node.left = removeMin(node.left);
        return node;
    }

    /**
     * 删除AVL平衡二叉树的最小值
     * @return
     */
    public V removeMin(){
        V minimum = minimum();
        removeMin(root);
        return minimum;
    }

    /**
     * 删除以node为根的AVL平衡二叉树中的指定元素
     * @param node
     * @param key
     * @return
     */
    private Node remove(Node node, K key){
        if(node == null){
            return null;
        }
        Node resultNode = null;

        if(key.compareTo(node.key) < 0){
            node.left = remove(node.left, key);
            resultNode = node;
        }else if(key.compareTo(node.key) > 0){
            node.right = remove(node.right, key);
            resultNode = node;
        }else /*if(key.compareTo(node.key) == 0)*/{
            //删除右子树为空的情况
            if(node.right==null){
                Node leftNode = node.left;
                node.left = null;
                size--;
                resultNode = leftNode;
            }
            //删除左子树为空的情况
            else if(node.left==null){
                Node rightNode = node.right;
                node.right = null;
                size--;
                resultNode = rightNode;
            }
            // 删除左子树、右子树均不为空的情况
            else{
                // 1、删除后用后继节点替代该位置(后继节点即待删除节点右子树中的最小节点)
                Node successor = minimum(node.right);
                // 删除后继节点，并让待删除节点的右子树成为后继节点的右子树
                successor.right = removeMin(node.right);
                // 让待删除节点的左子树成为后继节点的左子树
                successor.left = node.left;
                // 将待删除节点的左、右子节点置为空
                node.left = node.right = null;
                resultNode = successor;
                /**
                 // 2、删除后用前驱节点替代该位置(前驱节点即待删除节点左子树中的最大节点)
                 // 获得前驱节点
                 Node predecessor = maximize(node.left);
                 // 删除前驱节点，并让待删除节点的左子树成为前驱节点的左子树
                 predecessor.left = removeMax(node);
                 // 让待删除节点的右子树成为前驱节点的右子树
                 predecessor.right = node.right;
                 // 将待删除节点的左、右子节点置为空
                 node.left = node.right = null;
                 return predecessor;
                 */
            }
        }
        //维护平衡
        return keepBalance(resultNode);
    }

    public V remove(K key){
        Node node = getNode(root, key);
        if(node!=null){
            root = remove(root,key);
            return node.value;
        }
        return null;
    }


}

```









## 堆(Heap)

数组based的堆 data[] 

- 0开始的堆, 父节点 左右节点的关系
  - parent = (left-1)/2 = (right-1)/2
  - left = parent*2+1
  - right = parent*2+2
- 1开始的堆, 父节点 左右节点的关系
  - parent = left/2 = right/2
  - left = parent*2
  - right = parent*2+1

堆中某个节点的值总是不大于或不小于其父节点的值；
堆总是一棵完全二叉树。

堆是一颗完全二叉树，每次总是先填满上一层，再在下一层从左往右依次插入, 

在这棵树中，所有父节点都满足大于等于其子节点的堆叫大根堆，所有父节点都满足小于等于其子节点的堆叫小根堆。



### 建堆 heapify()

1. 根据传入的数组, 将元素依次插入堆中的数组, 
2. 从最后一个元素的父节点开始下沉
3. 所有需要下沉的元素下沉完毕以后, 堆建好了

```java
/**
     * 传入数组建堆
     * @param array
     */
public MinHeap(E[] array){
    this(array.length);
    //所有元素入堆
    for(int i=0; i<array.length; i++){
        data.addLast(array[i]);
    }
    //建堆
    heapify();
}

/**
     * 建堆
     */
private void heapify(){
    //最后一层的不需要shiftdown 从最后一个元素的父节点开始即可
    // parent(data.getSize()-1) = (size-1)/2
    for(int i=parent(data.getSize()-1); i>=0; i--){
        shiftDown(i);
    }
}
```









### 插入 shiftUp()

1. 将新元素增加到堆的末尾
2. 按照优先顺序，将新元素与其父节点比较，如果新元素小于父节点(小根堆)则将两者交换位置。
3. 不断进行第2步操作，直到不需要交换新元素和父节点，或者达到堆顶
4. 最后通过得到一个最小堆

通过将新元素与父节点调整交换的操作叫做**上滤(percolate up)**。

![image-20210804120749267](数据结构.assets/image-20210804120749267.png)

```java
/**
     * 将index位置的元素上移到适合的位置
     * 这个位置应该使得这个元素大于父节点的值
     * @param index
     */
public void shiftUp(int index){
    //只要没有到达根位置, 并且index父节点的值>index位置的值
    while(index>0 && data.get(parent(index)).compareTo(data.get(index))>0){
        //交换父节点和index位置的元素
        data.swap(index, parent(index));
        //更新index为父节点的index
        index = parent(index);
    }
}
```

### 删除 shiftDown()

堆的删除操作与插入操作相反，插入操作从下往上调整堆，而删除操作则从上往下调整堆

1. 删除堆顶元素（通常是将堆顶元素与数组的末尾元素交换）
2. size--
3. 将堆顶的元素下沉, 与左右子节点比较
   1. 如果小于两个当中较小的那个, 结束下沉
   2. 如果大于较小的那个, 将两个元素交换, 继续下沉
4. 结束下沉的时候得到一个小根堆

这里图示是大根堆, 但是原理是相同的只是改变了交换时判断条件

![image-20210804121056515](数据结构.assets/image-20210804121056515.png)

```java
/**
     * 将index位置的元素下沉到适合的位置
     * 这个位置应该使得这个元素小于左右子节点中最小的那个
     * @param index
     */
public void shiftDown(int index){
    //只要index还有左子节点
    while(index>=0 && leftChild(index)<data.getSize()){
        //左子节点的下标
        int left = leftChild(index);
        //比较左右子节点选出最小的那个
        if(left+1<data.getSize() && data.get(left+1).compareTo(data.get(left))<0){
            left = rightChild(index);
        }
        //如果index位置的元素已经小于左右子节点中的最小的, 无需下沉
        if(data.get(index).compareTo(data.get(left))<0){
            break;
        }
        //下沉, 与左右子节点中最小的那个交换
        data.swap(index, left);
        //更新下标
        index = left;
    }
}
```



### 完整实现

```java
package com.ccq.Heap_With_Generalization;

/** 最小堆
 * 完全二叉树实现、树中的根结点都表示树中的最小元素结点
 * 0开始:
 *      LeftChild = index*2+1
 *      RightChild = index*2+2
 *      Parent = (index-1)/2
 * @author Chaoqun Cheng
 * @date 2021-08-2021/8/3-11:20
 */

public class MinHeap<E extends Comparable<E>> {

    //数组存放在自定义的Array数组中
    private Array<E> data;

    /**
     * 指定初始容量的构造器
     * @param capacity
     */
    public MinHeap(int capacity){
        data = new Array<>(capacity);
    }

    /**
     * 默认初始容量创建底层数组
     */
    public MinHeap(){
        data = new Array<>();
    }

    /**
     * 传入数组建堆
     * @param array
     */
    public MinHeap(E[] array){
        this(array.length);
        //所有元素入堆
        for(int i=0; i<array.length; i++){
            data.addLast(array[i]);
        }
        heapify();
    }

    /**
     * 建堆
     */
    private void heapify(){
        //最后一层的不需要shiftdown 从最后一个元素的父节点开始即可
        for(int i=parent(data.getSize()-1); i>=0; i--){
            shiftDown(i);
        }
    }

    //================================获取底层数组大小===========================

    /**
     * 获取数组大小
     * @return
     */
    public int size(){
        return data.getSize();
    }

    /**
     * 查看数组是否有元素
     * @return
     */
    public boolean isEmpty(){
        return data.isEmpty();
    }

    //================================获取父节点 左右子节点===========================

    /**
     * 获取index位置的父节点在数组中的下标
     * @param index
     * @return
     */
    public int parent(int index){
        if(index==0){
            throw new IllegalArgumentException("根结点没有父节点");
        }
        return (index-1)/2;
    }

    /**
     * 获取index位置左子节点在数组中的下标
     * @param index
     * @return
     */
    public int leftChild(int index){
        return index*2+1;
    }

    /**
     * 获取index位置右子节点在数组中的下标
     * @param index
     * @return
     */
    public int rightChild(int index){
        return index*2+2;
    }



    //================================元素上升下沉===========================

    /**
     * 将index位置的元素上移到适合的位置
     * 这个位置应该使得这个元素大于父节点的值
     * @param index
     */
    public void shiftUp(int index){
        //只要没有到达根位置, 并且index父节点的值>index位置的值
        while(index>0 && data.get(parent(index)).compareTo(data.get(index))>0){
            //交换父节点和index位置的元素
            data.swap(index, parent(index));
            //更新index为父节点的index
            index = parent(index);
        }
    }

    /**
     * 将index位置的元素下沉到适合的位置
     * 这个位置应该使得这个元素小于左右子节点中最小的那个
     * @param index
     */
    public void shiftDown(int index){
        //只要index还有左子节点
        while(index>=0 && leftChild(index)<data.getSize()){
            //左子节点的下标
            int left = leftChild(index);
            //比较左右子节点选出最小的那个
            if(left+1<data.getSize() && data.get(left+1).compareTo(data.get(left))<0){
                left = rightChild(index);
            }
            //如果index位置的元素已经小于左右子节点中的最小的, 无需下沉
            if(data.get(index).compareTo(data.get(left))<0){
                break;
            }
            //下沉, 与左右子节点中最小的那个交换
            data.swap(index, left);
            //更新下标
            index = left;
        }
    }

    //================================向堆中插入元素===========================
    /**
     * 向堆中插入元素
     * @param e
     */
    public void add(E e){
        //每次都加入到数组的最后
        data.addLast(e);
        //然后将这个元素上浮到合适的位置
        shiftUp(data.getSize()-1);
    }

    //================================获取堆中的最小值===========================

    /**
     * 获取堆顶的元素
     * @return
     */
    public E findMin(){
        if(data.isEmpty()){
            throw new IllegalArgumentException("堆空");
        }
        return data.get(0);
    }

    /**
     * 获取堆顶的元素并且将这个元素从堆中删除
     * @return
     */
    public E extractMin(){
        //获取堆顶元素
        E top = findMin();
        //将数组最后一个位置的元素和堆顶元素交换
        data.swap(0, data.getSize()-1);
        //删除交换后最后一个元素
        data.removeLast();
        //将交换到堆顶的元素下沉到合适的位置
        shiftDown(0);
        //之前堆顶的元素
        return top;
    }
}

```







## 红黑树

https://blog.csdn.net/xiaofeng10330111/article/details/106080394?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162740012116780265489543%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162740012116780265489543&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-106080394.pc_search_result_before_js&utm_term=%E7%BA%A2%E9%BB%91%E6%A0%91&spm=1018.2226.3001.4187



TreeMap TreeSet HashMap

### 对红黑树的基本定义理解

红黑树的英文是“Red-Black Tree”，简称 R-B Tree，它是一种不严格的平衡二叉查找树

![image-20210728011623293](数据结构.assets/image-20210728011623293.png)

红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：

- 根节点是黑色的；
- 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据（图中将黑色的、空的叶子节点都省略掉了）；
- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
  -  每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

### 对红黑树是“近似平衡”的理解

平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重。

一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 log2n，所以如果要证明红黑树是近似平衡的，只需要分析，红黑树的高度是否比较稳定地趋近 log2n 就好了。

#### 1.将红色节点从红黑树中去掉，分析包含黑色节点的红黑树的高度

红色节点删除之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树。

![image-20210728011751505](数据结构.assets/image-20210728011751505.png)

从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。

完全二叉树的高度近似 log2n，这里的四叉“黑树”的高度要低于完全二叉树，所以去掉红色节点的“黑树”的高度也不会超过 log2n。


#### 把红色节点加回去，分析高度变化

在红黑树中，红色节点不能相邻，也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。

红黑树中包含最多黑色节点的路径不会超过 log2n，所以加入红色节点之后，最长路径不会超过 2log2n，也就是说，红黑树的高度近似 2log2n。

所以，红黑树的高度只比高度平衡的 AVL 树的高度（log2n）仅仅大了一倍，在性能上，下降得并不多。这样推导出来的结果不够精确，实际上红黑树的性能更好。


### **红黑树与AVL树的比较：**

- AVL树的时间复杂度虽然优于红黑树，但是对于现在的计算机，cpu太快，可以忽略性能差异
- 红黑树的插入删除比AVL树更便于控制操作
- 红黑树整体性能略优于AVL树（红黑树旋转情况少于AVL树）



### 实现红黑树的基本思想分析

红黑树的平衡过程跟魔方复原非常神似，大致过程就是：遇到什么样的节点排布，我们就对应怎么去调整。只要按照这些固定的调整规则来操作，就能将一个非平衡的红黑树调整成平衡的。

如上，一棵合格的红黑树需要满足的四个基本要求中，在插入、删除节点的过程中，第三、第四点要求可能会被破坏，而“平衡调整”实际上就是要把被破坏的第三、第四点恢复过来。具体分析如下：

#### 理解左旋（rotate left）、右旋（rotate right）操作

左旋就是围绕某个节点的左旋，图中的 a，b，r 表示子树，可以为空。

逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子

![image-20210728012014045](数据结构.assets/image-20210728012014045.png)

```java
/**
     * 功能描述：左旋右侧需要平衡
     *
     * @author yanfengzhang
     * @date 2020-05-27 14:57
     */
    private void rotateLeft(Entry<K, V> p) {
        if (p != null) {
            /*拿到根节点的右子节点 */
            Entry<K, V> r = p.right;
            /*把根节点的右子节点的左节点，赋值*/
            p.right = r.left;
            if (r.left != null)
                /*将根节点这个值赋值到当前断开的跟节点上*/ {
                r.left.parent = p;
            }
            /*r 将来要成为新的根节点 p.parent 为根 ，使得他为新的跟节点 */
            r.parent = p.parent;
            if (p.parent == null) {
                root = r;
            }
            /*如果p 为左孩子，让他还是成为左孩子 同理*/
            else if (p.parent.left == p) {
                p.parent.left = r;
            } else {
                p.parent.right = r;
            }
            /*最后 将当前交换的跟换值*/
            r.left = p;
            p.parent = r;
        }
    }
```

右旋就是围绕某个节点的右旋，图中的 a，b，r 表示子树，可以为空。

顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。

![image-20210728012107747](数据结构.assets/image-20210728012107747.png)

```java
    /**
     * 功能描述：右旋代码
     *
     * @author yanfengzhang
     * @date 2020-05-27 14:58
     */
    private void rotateRight(Entry<K, V> p) {
        if (p != null) {
            Entry<K, V> l = p.left;
            p.left = l.right;
            if (l.right != null) {
                l.right.parent = p;
            }
            l.parent = p.parent;
            if (p.parent == null) {
                root = l;
            } else if (p.parent.right == p) {
                p.parent.right = l;
            } else {
                p.parent.left = l;
            }
            l.right = p;
            p.parent = l;
        }
    }
```

#### 插入操作的平衡调整

红黑树规定，**插入的节点必须是红色的**。而且，二叉查找树中新插入的节点都是放在叶子节点上。

关于插入操作的平衡调整，有这样两种特殊情况：

- 如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。
- 如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。

除此之外，其他情况都会违背红黑树的定义，需要进行调整，调整的过程包含两种基础的操作：左右旋转和改变颜色。

红黑树的平衡调整过程是一个迭代的过程。把正在处理的节点叫作关注节点。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。新节点插入之后，如果红黑树的平衡被打破，那一般会有下面三种情况：

备注：我们只需要根据每种情况的特点，不停地调整，就可以让红黑树继续符合定义，也就是继续保持平衡。为了简化描述，把父节点的兄弟节点叫作叔叔节点，父节点的父节点叫作祖父节点。

##### 情况一：如果关注节点是 a，它的叔叔节点 d 是红色

![image-20210728012325033](数据结构.assets/image-20210728012325033.png)

具体操作为：

- 将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；
- 将关注节点 a 的祖父节点 c 的颜色设置成红色；
- 关注节点变成 a 的祖父节点 c；
- 跳到情况二或者情况三。

##### 情况二：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点

![image-20210728012440700](数据结构.assets/image-20210728012440700.png)

具体操作为：关注节点变成节点 a 的父节点 b；围绕新的关注节点b 左旋；跳到情况三。

##### 情况三：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点

![image-20210728012523082](数据结构.assets/image-20210728012523082.png)



具体操作为：围绕关注节点 a 的祖父节点 c 右旋；将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换，调整结束。

```java
    /**
     * 功能描述：插入一个节点
     *
     * @author yanfengzhang
     * @date 2020-05-27 15:07
     */
    private void insert(RBTreeNode<T> node) {
        int cmp;
        RBTreeNode<T> root = this.rootNode;
        RBTreeNode<T> parent = null;
 
        /*定位节点添加到哪个父节点下*/
        while (null != root) {
            parent = root;
            cmp = node.key.compareTo(root.key);
            if (cmp < 0) {
                root = root.left;
            } else {
                root = root.right;
            }
        }
 
        node.parent = parent;
        /*表示当前没一个节点，那么就当新增的节点为根节点*/
        if (null == parent) {
            this.rootNode = node;
        } else {
            //找出在当前父节点下新增节点的位置
            cmp = node.key.compareTo(parent.key);
            if (cmp < 0) {
                parent.left = node;
            } else {
                parent.right = node;
            }
        }
 
        /*设置插入节点的颜色为红色*/
        node.color = COLOR_RED;
 
        /*修正为红黑树*/
        insertFixUp(node);
    }
 
    /**
     * 功能描述：红黑树插入修正
     *
     * @author yanfengzhang
     * @date 2020-05-27 15:07
     */
    private void insertFixUp(RBTreeNode<T> node) {
        RBTreeNode<T> parent, gparent;
        /*节点的父节点存在并且为红色*/
        while (((parent = getParent(node)) != null) && isRed(parent)) {
            gparent = getParent(parent);
 
            /*如果其祖父节点是空怎么处理, 若父节点是祖父节点的左孩子*/
            if (parent == gparent.left) {
                RBTreeNode<T> uncle = gparent.right;
                if ((null != uncle) && isRed(uncle)) {
                    setColorBlack(uncle);
                    setColorBlack(parent);
                    setColorRed(gparent);
                    node = gparent;
                    continue;
                }
 
                if (parent.right == node) {
                    RBTreeNode<T> tmp;
                    leftRotate(parent);
                    tmp = parent;
                    parent = node;
                    node = tmp;
                }
 
                setColorBlack(parent);
                setColorRed(gparent);
                rightRotate(gparent);
            } else {
                RBTreeNode<T> uncle = gparent.left;
                if ((null != uncle) && isRed(uncle)) {
                    setColorBlack(uncle);
                    setColorBlack(parent);
                    setColorRed(gparent);
                    node = gparent;
                    continue;
                }
 
                if (parent.left == node) {
                    RBTreeNode<T> tmp;
                    rightRotate(parent);
                    tmp = parent;
                    parent = node;
                    node = tmp;
                }
 
                setColorBlack(parent);
                setColorRed(gparent);
                leftRotate(gparent);
            }
        }
        setColorBlack(this.rootNode);
    }
```

#### 删除操作的平衡调整

删除操作的平衡调整分为两步：

- 第一步是针对删除节点初步调整。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；
- 第二步是针对关注节点进行二次调整，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。

##### 针对删除节点初步调整

红黑树的定义中“只包含红色节点和黑色节点”，经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。

备注：如果一个节点既可以是红色，也可以是黑色，图中用一半红色一半黑色来表示。如果一个节点是“红 - 黑”或者“黑 - 黑”，图中用左上角的一个小黑点来表示额外的黑色。

###### 情况一：如果要删除的节点是 a，它只有一个子节点 b

![image-20210728094943692](数据结构.assets/image-20210728094943692.png)



具体操作为：

- 删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作跟普通的二叉查找树的删除操作一样；
- 节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。
- 这种情况下，我们把节点 b 改为黑色；调整结束，不需要进行二次调整。

###### 情况二：如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c

![image-20210728095058803](数据结构.assets/image-20210728095058803.png)

具体操作为：

- 如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。
- 我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置。这一部分操作跟普通的二叉查找树的删除操作无异；
- 然后把节点 c 的颜色设置为跟节点 a 相同的颜色；
- 如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红 - 黑”或者“黑 - 黑”；
- 这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。

###### 情况三：如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点

![image-20210728095253934](数据结构.assets/image-20210728095253934.png)



具体操作为：

- 找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 CASE 1；
- 将节点 a 替换成后继节点 d；
- 把节点 d 的颜色设置为跟节点 a 相同的颜色；
- 如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；
- 这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。
  

##### 针对关注节点进行二次调整

初步调整之后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点。针对这个关注节点，再分四种情况来进行二次调整。

备注：二次调整是为了让红黑树中不存在相邻的红色节点。

###### 情况一：如果关注节点是 a，它的兄弟节点 c 是红色的

![image-20210728095456517](数据结构.assets/image-20210728095456517.png)

具体操作：

- 围绕关注节点 a 的父节点 b 左旋；
- 关注节点 a 的父节点 b 和祖父节点 c 交换颜色；
- 关注节点不变；继续从四种情况中选择适合的规则来调整。

###### 情况二：如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的

![image-20210728095528826](数据结构.assets/image-20210728095528826.png)



具体操作：

- 将关注节点 a 的兄弟节点 c 的颜色变成红色；
- 从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；
- 给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”；
- 关注节点从 a 变成其父节点 b；继续从四种情况中选择符合的规则来调整。
  

###### 情况三：如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色

![image-20210728095700631](数据结构.assets/image-20210728095700631.png)

具体操作：

- 围绕关注节点 a 的兄弟节点 c 右旋；
- 节点 c 和节点 d 交换颜色；
- 关注节点不变；
- 跳转到 CASE 4，继续调整。



###### 情况四：如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的

![image-20210728095815786](数据结构.assets/image-20210728095815786.png)

具体操作：

- 围绕关注节点 a 的父节点 b 左旋；
- 将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；
- 将关注节点 a 的父节点 b 的颜色设置为黑色；
- 从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；
- 将关注节点 a 的叔叔节点 e 设置为黑色；调整结束。
  

```java
    /**
     * 功能描述：删除节点
     *
     * @author yanfengzhang
     * @date 2020-05-27 15:11
     */
    private void remove(RBTreeNode<T> node) {
        RBTreeNode<T> child, parent;
        boolean color;
        /*被删除节点左右孩子都不为空的情况*/
        if ((null != node.left) && (null != node.right)) {
 
            /*获取到被删除节点的后继节点*/
            RBTreeNode<T> replace = node;
 
            replace = replace.right;
            while (null != replace.left) {
                replace = replace.left;
            }
 
            /*node节点不是根节点*/
            if (null != getParent(node)) {
                /*node是左节点*/
                if (getParent(node).left == node) {
                    getParent(node).left = replace;
                } else {
                    getParent(node).right = replace;
                }
            } else {
                this.rootNode = replace;
            }
 
            child = replace.right;
            parent = getParent(replace);
            color = getColor(replace);
 
            if (parent == node) {
                parent = replace;
            } else {
                if (null != child) {
                    setParent(child, parent);
                }
                parent.left = child;
 
                replace.right = node.right;
                setParent(node.right, replace);
            }
 
            replace.parent = node.parent;
            replace.color = node.color;
            replace.left = node.left;
            node.left.parent = replace;
            if (color == COLOR_BLACK) {
                removeFixUp(child, parent);
            }
 
            node = null;
            return;
        }
 
        if (null != node.left) {
            child = node.left;
        } else {
            child = node.right;
        }
 
        parent = node.parent;
        color = node.color;
        if (null != child) {
            child.parent = parent;
        }
 
        if (null != parent) {
            if (parent.left == node) {
                parent.left = child;
            } else {
                parent.right = child;
            }
        } else {
            this.rootNode = child;
        }
 
        if (color == COLOR_BLACK) {
            removeFixUp(child, parent);
        }
        node = null;
    }
 
    /**
     * 功能描述：删除修复
     *
     * @author yanfengzhang
     * @date 2020-05-27 15:11
     */
    private void removeFixUp(RBTreeNode<T> node, RBTreeNode<T> parent) {
        RBTreeNode<T> other;
        /*node不为空且为黑色，并且不为根节点*/
        while ((null == node || isBlack(node)) && (node != this.rootNode)) {
            /*node是父节点的左孩子*/
            if (node == parent.left) {
                /*获取到其右孩子*/
                other = parent.right;
                /*node节点的兄弟节点是红色*/
                if (isRed(other)) {
                    setColorBlack(other);
                    setColorRed(parent);
                    leftRotate(parent);
                    other = parent.right;
                }
 
                /*node节点的兄弟节点是黑色，且兄弟节点的两个孩子节点也是黑色*/
                if ((other.left == null || isBlack(other.left)) &&
                        (other.right == null || isBlack(other.right))) {
                    setColorRed(other);
                    node = parent;
                    parent = getParent(node);
                } else {
                    /*node节点的兄弟节点是黑色，且兄弟节点的右孩子是红色*/
                    if (null == other.right || isBlack(other.right)) {
                        setColorBlack(other.left);
                        setColorRed(other);
                        rightRotate(other);
                        other = parent.right;
                    }
                    /*node节点的兄弟节点是黑色，且兄弟节点的右孩子是红色，左孩子是任意颜色*/
                    setColor(other, getColor(parent));
                    setColorBlack(parent);
                    setColorBlack(other.right);
                    leftRotate(parent);
                    node = this.rootNode;
                    break;
                }
            } else {
                other = parent.left;
                if (isRed(other)) {
                    setColorBlack(other);
                    setColorRed(parent);
                    rightRotate(parent);
                    other = parent.left;
                }
 
                if ((null == other.left || isBlack(other.left)) &&
                        (null == other.right || isBlack(other.right))) {
                    setColorRed(other);
                    node = parent;
                    parent = getParent(node);
                } else {
                    if (null == other.left || isBlack(other.left)) {
                        setColorBlack(other.right);
                        setColorRed(other);
                        leftRotate(other);
                        other = parent.left;
                    }
 
                    setColor(other, getColor(parent));
                    setColorBlack(parent);
                    setColorBlack(other.left);
                    rightRotate(parent);
                    node = this.rootNode;
                    break;
                }
            }
        }
        if (node != null) {
            setColorBlack(node);
        }
    }
```



### 自己的实现

```java
package com.ccq.Red_Black_Tree;


/**红黑树
 * @author Chaoqun Cheng
 * @date 2021-08-2021/8/3-13:02
 */

public class RedBlackTree<K extends Comparable<K>, V>{
    private static final boolean RED = true;
    private static final boolean BLACK = false;

    /**
     * 内部结点类
     */
    private class Node{
        public K key;
        public V value;
        public Node left, right;
        public boolean color;
        public Node(K _key, V _value){
            key = _key;
            value = _value;
            left = null;
            right = null;
            //插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。
            color = RED;
        }
    }

    /**
     * 红黑树的根结点
     */
    private Node root;
    /**
     * 红黑树中结点数量
     */
    private int size;

    public RedBlackTree(){
        root = null;
        size = 0;
    }

    public boolean isEmpty(){
        return size==0;
    }

    public int getSize(){
        return size;
    }

    public boolean contains(K key){
        return getNode(root,key)!=null;
    }

    public V get(K key){
        Node node = getNode(root, key);
        return node==null?null:node.value;
    }
    public void set(K key, V value){
        Node node = getNode(root, key);
        if(node==null){
            throw new IllegalArgumentException("no such key");
        }
        node.value = value;
    }


    //==============================旋转 && 变色===============================

    /**
     *  左旋
     //   node                     x
     //  /   \     左旋转         /  \
     // T1   x   --------->   node   T3
     //     / \              /   \
     //    T2 T3            T1   T2
     * @param node
     * @return
     */
    private Node leftRotate(Node node){
        Node curRight = node.right;
        //左旋
        node.right = curRight.left;
        curRight.left = node;
        curRight.color = node.color;
        node.color = RED;
        return curRight;
    }

    /**
     * 右旋
     //     node                   x
     //    /   \     右旋转       /  \
     //   x    T2   ------->   y   node
     //  / \                       /  \
     // y  T1                     T1  T2
     * @param node
     * @return
     */
    private Node rightRotate(Node node){
        Node curLeft = node.left;
        //右旋
        node.left = curLeft.right;
        curLeft.right = node;
        curLeft.color = node.color;
        node.color = RED;
        return curLeft;
    }

    /**
     * 将node颜色变成红色
     * 左右子节点都变成黑色
     * @param node
     */
    private void flipColor(Node node){
        node.color = RED;
        node.left.color = BLACK;
        node.right.color = BLACK;
    }

    /**
     * 判断当前结点是否是红色
     * @param node
     * @return
     */
    public boolean isRed(Node node){
        if(node==null){
            return BLACK;
        }
        return node.color;
    }

    //==============================向红黑树中插入节点===============================
    public Node add(Node node, K key, V value){
        //递归终止条件
        if(node==null){
            size++;
            return new Node(key,value);
        }
        //左右子树递归
        if(key.compareTo(node.key)<0){
            node.left = add(node.left, key, value);
        }else if(key.compareTo(node.key)>0){
            node.right = add(node.right, key, value);
        }else /*key.compareTo(node.key)==0*/{
            node.value = value;
        }
        //插入节点后, 查看 是否需要旋转来保证红黑树的性质
        /**==========维护红黑树性质 Start==========*/

        //判断是否需要左旋转
        if(isRed(node.right) && !isRed(node.left)){
            node = leftRotate(node);
        }
        //判断是否需要右旋转
        if(isRed(node.left) && isRed(node.left.left)){
            node = rightRotate(node);
        }
        //判断颜色是否需要翻转
        if(isRed(node.left) && isRed(node.right)){
            flipColor(node);
        }
        /**==========维护红黑树性质 Start==========*/
        return node;
    }

    /**
     * 插入一个结点
     * @param key
     * @param value
     */
    public void add(K key, V value){
        root = add(root,key,value);
        root.color = BLACK;
    }

    //==============================从红黑树中查找节点===============================
    private void checkEmpty(){
        if(isEmpty()){
            throw new IllegalArgumentException("BinarySearchTree is empty !");
        }
    }

    /**
     * 根据key获取对应的红黑树中的结点
     * @param node
     * @param key
     * @return
     */
    public Node getNode(Node node, K key){
        if(node==null){
            return null;
        }
        if(key.compareTo(node.key)<0){
            return getNode(node.left, key);
        }else if(key.compareTo(node.key)>0){
            return getNode(node.right, key);
        }else{
            return node;
        }
    }

    /**
     * 查找以node为根节点红黑树的最小节点
     * @param node
     * @return
     */
    private Node minimum(Node node){
        checkEmpty();
        if(node.left==null){
            return node;
        }
        return minimum(node.left);
    }

    /**
     * 查找红黑树的最小值
     * @return
     */
    public V minimum(){
        checkEmpty();
        return minimum(root).value;
    }

    /**
     * 查找红黑树的最大值
     * @return
     */
    public V maximum(){
        checkEmpty();
        return maximum(root).value;
    }

    /**
     * 查找以node为根节点红黑树的最大节点
     * @param node
     * @return
     */
    private Node maximum(Node node){
        checkEmpty();
        if(node.right==null){
            return node;
        }
        return maximum(node.right);
    }

    //==============================从红黑树中删除节点===============================

    /**
     * 删除以node为根的红黑树的最大节点
     * @param node
     * @return
     */
    private Node removeMax(Node node){
        if(node.right==null){
            Node leftNode = node.left;
            node.left = null;
            size--;
            return leftNode;
        }
        node.right = removeMax(node.right);
        return node;
    }

    /**
     * 删除红黑树的最大值
     * @return
     */
    public V removeMax(){
        // 获取最大值
        V maximum = maximum();
        // 删除最大结点
        removeMax(root);
        return maximum;
    }

    /**
     * 删除以node为根的红黑树的最小节点
     * @param node
     * @return
     */
    private Node removeMin(Node node){
        if(node.left==null){
            Node rightNode = node.right;
            node.right = null;
            size--;
            return rightNode;
        }
        node.left = removeMin(node.left);
        return node;
    }

    /**
     * 删除红黑树的最小值
     * @return
     */
    public V removeMin(){
        V minimum = minimum();
        removeMin(root);
        return minimum;
    }

    private Node remove(Node node, K key){
        if(node==null){
            return null;
        }
        if(key.compareTo(node.key)<0){
            node.left = remove(node.left, key);
            return node;
        }else if(key.compareTo(node.key)>0){
            node.right = remove(node.right, key);
            return node;
        }else /*key.compareTo(node.key)==0*/{
            if(node.left==null){
                Node rightNode = node.right;
                node.right = null;
                size--;
                return rightNode;
            }else if(node.right==null){
                Node leftNode = node.left;
                node.left = null;
                size--;
                return leftNode;
            }else{
                //1、删除后用后继节点替代该位置(后继节点即待删除节点右子树中的最小节点)
                //获得后继节点
                Node rightMin = minimum(node.right);
                //// 删除后继节点，并让待删除节点的右子树成为后继节点的右子树
                rightMin.right = removeMin(node.right);
                // 让待删除节点的左子树成为后继节点的左子树
                rightMin.left = node.left;
                // 将待删除节点的左、右子节点置为空
                node.left = node.right = null;
                return rightMin;
                /**
                 // 2、删除后用前驱节点替代该位置(前驱节点即待删除节点左子树中的最大节点)
                 // 获得前驱节点
                 Node predecessor = maximize(node.left);
                 // 删除前驱节点，并让待删除节点的左子树成为前驱节点的左子树
                 predecessor.left = removeMax(node.left);
                 // 让待删除节点的右子树成为前驱节点的右子树
                 predecessor.right = node.right;
                 // 将待删除节点的左、右子节点置为空
                 node.left = node.right = null;
                 return predecessor;
                 */
            }
        }
    }

}

```























































































































## HashMap

https://blog.csdn.net/zhengwangzw/article/details/104889549?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162731499816780264041105%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162731499816780264041105&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-104889549.pc_search_result_before_js&utm_term=HashMap&spm=1018.2226.3001.4187

### 内部结构

JDK1.8 数组+链表红黑树

![image-20210727004842218](数据结构.assets/image-20210727004842218.png)

### 插入原理(put)

1. 判断数组是否为空，为空进行初始化;
2. 不为空，计算 k 的 hash 值，通过(n - 1) & hash计算应当存放在数组中的下标 index;
3. 查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；
4. 存在数据，说明发生了hash冲突(存在二个节点key的hash值一样), 继续判断key是否相等，相等，用新的value替换原数据(onlyIfAbsent为false)；
5. 如果不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中；(如果当前节点是树型节点证明当前已经是红黑树了)
6. 如果不是树型节点，创建普通Node加入链表中；判断链表长度是否大于 8并且数组长度大于64， 大于的话链表转换为红黑树；
7. 插入完成之后判断当前节点数是否大于阈值，如果大于开始扩容为原数组的二倍。



![image-20210727004923422](数据结构.assets/image-20210727004923422.png)

![image-20210727092932153](数据结构.assets/image-20210727092932153.png)

### HashMap怎么设定初始容量大小

一般如果`new HashMap()` 不传值，默认大小是16，负载因子是0.75， 

如果自己传入初始大小k，初始化大小为 大于k的 2的整数次方，例如如果传10，大小为16

```java
/**
     * Returns a power of two size for the given target capacity.
     */
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```



>补充说明：下图是详细过程，算法就是让初始二进制右移1，2，4，8，16位，分别与自己位或，把高位第一个为1的数通过不断右移，把高位为1的后面全变为1，最后再进行+1操作，111111 + 1 = 1000000 = 2^62   （符合大于50并且是2的整数次幂 ）
>![image-20210727005353532](数据结构.assets/image-20210727005353532.png)
>
>



### HashMap的哈希函数怎么设计的

https://blog.csdn.net/zhengwangzw/article/details/104889549?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162731499816780264041105%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162731499816780264041105&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-104889549.pc_search_result_before_js&utm_term=HashMap&spm=1018.2226.3001.4187

hash函数是先拿到 key 的hashcode，是一个32位的int值，然后让hashcode的高16位和低16位进行异或操作。

```java
/**
     * Computes key.hashCode() and spreads (XORs) higher bits of hash
     * to lower.  Because the table uses power-of-two masking, sets of
     * hashes that vary only in bits above the current mask will
     * always collide. (Among known examples are sets of Float keys
     * holding consecutive whole numbers in small tables.)  So we
     * apply a transform that spreads the impact of higher bits
     * downward. There is a tradeoff between speed, utility, and
     * quality of bit-spreading. Because many common sets of hashes
     * are already reasonably distributed (so don't benefit from
     * spreading), and because we use trees to handle large sets of
     * collisions in bins, we just XOR some shifted bits in the
     * cheapest possible way to reduce systematic lossage, as well as
     * to incorporate impact of the highest bits that would otherwise
     * never be used in index calculations because of table bounds.
     */
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```



#### 为什么这么设计吗？

扰动函数, 原因有两点

1. 一定要尽可能降低hash碰撞，越分散越好；
2. 算法一定要尽可能高效，因为这是高频操作, 因此采用位运算；

#### 为什么采用hashcode的高16位和低16位异或能降低hash碰撞？hash函数能不能直接用key的hashcode？

因为key.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值。int值范围为**-2147483648~2147483647**，前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。

但问题是一个40亿长度的数组，内存是放不下的。如果HashMap数组的初始大小才16，用之前需要对数组的长度取模运算，得到的余数才能用来访问数组下标

源码中模运算就是把散列值和数组长度-1做一个"与"操作，位运算比取余%运算要快。

```C
bucketIndex = indexFor(hash, table.length);

static int indexFor(int h, int length) {
     return h & (length-1);
}

```



这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为这样（数组长度-1）正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。

```
  10100101 11000100 00100101
& 00000000 00000000 00001111
----------------------------------
  00000000 00000000 00000101    //高位全部归零，只保留末四位

```



但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，如果正好让最后几个低位呈现规律性重复，就无比蛋疼。这时候“扰动函数”的价值就体现出来了

![image-20210727010300685](数据结构.assets/image-20210727010300685.png)

右移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。

另外Java1.8相比1.7做了调整，1.7做了四次移位和四次异或，但明显Java 8觉得扰动做一次就够了，做4次的话，多了可能边际效用也不大，所谓为了效率考虑就改成一次了。

```javastatic int hash(int h) {
static int hash(int h) {
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}

```

### 1.8还有有哪些优化吗？为什么这么优化?

#### 数组+链表改成了数组+链表或红黑树；

1. 防止发生hash冲突，链表长度过长，将时间复杂度由`O(n)`降为`O(logn)`;

#### 链表的插入方式从头插法改成了尾插法，简单说就是插入时，

1. 如果数组位置上已经有元素，

   1. 1.7将新元素放到数组中，原始节点作为新节点的后继节点，
   2. 1.8遍历链表，将元素放置到链表的最后；

2. 因为1.7头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；

   1. A线程在插入节点B，B线程也在插入，遇到容量不够开始扩容，重新hash，放置元素，

   2. 采用头插法，后遍历到的B节点放入了头部，这样形成了环，如下图所示：

   3. <img src="数据结构.assets/image-20210727010702272.png" alt="image-20210727010702272" style="zoom:50%;" />

   4. 1.7的扩容调用transfer代码，如下所示：

   5. ```java
      void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;
        for (Entry<K,V> e : table) {
          while(null != e) {
            Entry<K,V> next = e.next;
            if (rehash) {
              e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            e.next = newTable[i]; //A线程如果执行到这一行挂起，B线程开始进行扩容
            newTable[i] = e;
            e = next;
          }
        }
      }
      ```



#### 扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小；

1. 扩容的时候为什么1.8 不用重新hash就可以直接定位原节点在新数据的位置呢?
   1. 这是由于扩容是扩大为原数组大小的2倍，用于计算数组位置的掩码仅仅只是高位多了一个1，怎么理解呢？
   2. 扩容前长度为16，用于计算(n-1) & hash 的二进制n-1为0000 1111，扩容为32后的二进制就高位多了1，为0001 1111。
   3. 因为是& 运算，1和任何数 & 都是它本身，那就分二种情况，如下图：原数据hashcode高位第4位为0和高位为1的情况；
   4. 第四位高位为0，重新hash数值不变，第四位为1，重新hash数值比原来大16（旧数组的容量）
   5. ![image-20210727011120677](数据结构.assets/image-20210727011120677.png)

#### 在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容；

### HashMap是线程安全的吗？

不是，

在多线程环境下，1.7 会产生死循环、数据丢失、数据覆盖的问题，

1.8 中会有数据覆盖的问题，

以1.8为例，当A线程判断index位置为空后正好挂起，B线程开始往index位置的写入节点数据，这时A线程恢复现场，执行赋值操作，就把A线程的数据给覆盖了；

还有++size这个地方也会造成多线程同时扩容等问题。

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
  Node<K,V>[] tab; Node<K,V> p; int n, i;
  if ((tab = table) == null || (n = tab.length) == 0)
    n = (tab = resize()).length;
  if ((p = tab[i = (n - 1) & hash]) == null)  //多线程执行到这里
    tab[i] = newNode(hash, key, value, null);
  else {
    Node<K,V> e; K k;
    if (p.hash == hash &&
        ((k = p.key) == key || (key != null && key.equals(k))))
      e = p;
    else if (p instanceof TreeNode) // 这里很重要
      e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
    else {
      for (int binCount = 0; ; ++binCount) {
        if ((e = p.next) == null) {
          p.next = newNode(hash, key, value, null);
          if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
            treeifyBin(tab, hash);
          break;
        }
        if (e.hash == hash &&
            ((k = e.key) == key || (key != null && key.equals(k))))
          break;
        p = e;
      }
    }
    if (e != null) { // existing mapping for key
      V oldValue = e.value;
      if (!onlyIfAbsent || oldValue == null)
        e.value = value;
      afterNodeAccess(e);
      return oldValue;
    }
  }
  ++modCount;
  if (++size > threshold) // 多个线程走到这，可能重复resize()
    resize();
  afterNodeInsertion(evict);
  return null;
}

```

### 怎么解决HashMap线程不安全的问题

Java中有HashTable、Collections.synchronizedMap、以及ConcurrentHashMap可以实现线程安全的Map。

HashTable是直接在操作方法上加synchronized关键字，锁住整个数组，粒度比较大，

Collections.synchronizedMap是使用Collections集合工具的内部类，通过传入Map封装出一个SynchronizedMap对象，内部定义了一个对象锁，方法内通过对象锁实现；

ConcurrentHashMap使用分段锁，降低了锁粒度，让并发度大大提高。

### ConcurrentHashMap的分段锁的实现原理?

ConcurrentHashMap成员变量使用volatile 修饰，免除了指令重排序，同时保证内存可见性，另外使用CAS操作和synchronized结合实现赋值操作，多线程操作只会锁住当前操作索引的节点。

如下图，线程A锁住A节点所在链表，线程B锁住B节点所在链表，操作互不干涉。
![image-20210727082618482](数据结构.assets/image-20210727082618482.png)



### 链表转红黑树是链表长度达到阈值，这个阈值是多少

阈值是8，红黑树转链表阈值为6

#### 为什么是8，不是16，32甚至是7 ？又为什么红黑树转链表的阈值是6，不是8了呢？

因为经过计算，在hash函数设计合理的情况下，发生hash碰撞8次的几率为百万分之6，概率说话。。因为8够用了，

至于为什么转回来是6，因为如果hash碰撞次数在8附近徘徊，会一直发生链表和红黑树的互相转化，为了预防这种情况的发生。



### HashMap源码分析

https://blog.csdn.net/crpxnmmafq/article/details/75331318?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162558865716780366574289%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162558865716780366574289&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-11-75331318.pc_search_result_control_group&utm_term=Java8+HashMap&spm=1018.2226.3001.4187

#### hashmap的13 个成员变量

```
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;
-> 数组默认初始容量：16
static final int MAXIMUM_CAPACITY = 1 << 30;
-> 数组最大容量2 ^ 30 次方
static final float DEFAULT_LOAD_FACTOR = 0.75f;
-> 默认负载因子的大小：0.75
static final int MIN_TREEIFY_CAPACITY = 64;
-> 树形最小容量：哈希表的最小树形化容量,超过此值允许表中桶转化成红黑树
static final int TREEIFY_THRESHOLD = 8;
-> 树形阈值：当链表长度达到8时，将链表转化为红黑树
static final int UNTREEIFY_THRESHOLD = 6;
-> 树形阈值：当链表长度小于6时，将红黑树转化为链表
transient int modCount; -> hashmap修改次数
int threshold; -> 可存储key-value 键值对的临界值 需要扩充时;值 = 容量 * 加载因子
transient int size; 已存储key-value 键值对数量
final float loadFactor; -> 负载因子
transient Set< Map.Entry< K,V >> entrySet; -> 缓存的键值对集合
transient Node< K,V>[] table; -> 链表数组（用于存储hashmap的数据）

```

#### 构造方法

```java
    /**
     * 默认无参构造方法：
     * 初始容量16
     * 负载因子0.75
     */
public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; 
    }
    /**
     * 参数为初始容量
     */
public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR); //调用HashMap(int initialCapacity, float loadFactor) 构造方法
    }
    /**
     * 参数为初始容量 和 负载因子
     */
public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);
     if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " + loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
    /**
     * 设置可存储的 key-value 键值对最大值
     * 返回值为传入参数最接近的且大于等于的2的n次方
     * 传入参数 3 -> 4
     * 传入参数 5 -> 8
     * 传入参数 32 -> 32
     * 传入参数 33 -> 64
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= 1 << 30) ? 1 << 30 : n + 1;
    }
    /*
     * 构造一个新的 HashMap与指定的相同的映射 Map 。
     */
    public HashMap(Map<? extends K, ? extends V> m) {
       this.loadFactor = DEFAULT_LOAD_FACTOR;
       putMapEntries(m, false);
   }
   // 具体实现将map 内元素遍历插入hash表中
    final void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {
        int s = m.size();
        if (s > 0) {
            if (table == null) { // pre-size
                float ft = ((float)s / loadFactor) + 1.0F;// ft代表 在默认负载因子下，该hashmap的容量
                int t = ((ft < (float)MAXIMUM_CAPACITY) ?
                         (int)ft : MAXIMUM_CAPACITY);// 相当于执行 (int)Math.floor(ft);
                if (t > threshold)
                    threshold = tableSizeFor(t);// 重新设置临界值
            }
            else if (s > threshold)
                resize();
            // 一次将元素插入 后面详细讲解
            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key), key, value, false,evict);
            }
        }
    }
```



#### Node<K,V> 存储结构

```java
// 用于存储key-value键值
// Map.Entry仅定义一些方法 因此不列出详细代码
static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next; // 保存下一个节点地址
        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            // 此处进行的地址的比较
            if (o == this)
                return true;
            // 此处调用equal方法，若该类重写equal方法则调用重写后的equal方法
            if (o instanceof Map.Entry) {
                Map.Entry<?,?> e = (Map.Entry<?,?>)o;
                if (Objects.equals(key, e.getKey()) &&
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
```



#### Put

```java
    /**
     * K - key（键） V - Value （值）
     */
public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
    /**
     * hashcode 计算方式
     * 若未重写hashcode方法 则调用object的hashcode方法
     * 涉及数据结构红黑树 再此不详细讲解
     * 当容量达到64 且 单个位置链表长度达到8 链表转化红黑树
     * 若 单个位置链表长度减小到6 将红黑树转化会链表
     */
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    } 
    /**
     * 插入key-value 键值对具体实现
     */
     final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        // 判断 若hashmap内没有值 则重构hashmap
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        // 若指定位置hashcode 未被占用 则直接将该键值对插入
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        // 发生冲突时 解决方法
        else {
            Node<K,V> e; K k;
            // 若地址相同 直接新值替换旧值
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            // 若冲突位置已经是红黑树作为存储结构 则将该键值对插入红黑树中
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            // 冲突位置不为红黑树 将该节点插入链表
            else {
                // 死循环
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        // 若此时链表内长度大于等于7 将链表转化为红黑树 并将节点插入
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    // 若带插入数据与存储数据有重复时 结束
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        // 若容量不足 则扩容
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
    /**
     * 调整底层用于存储数据的hashmap底层数组长度
     * 优化操作效率 -> 每次扩容 扩大为原来的2倍
     */
    final Node<K,V>[] resize() {
        Node<K,V>[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        // 是否可以扩容
        if (oldCap > 0) {
            // 若已经最大 没办法 让他冲突去吧
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            // 将容量翻倍
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr << 1; // double threshold
        }
        // 如果旧容量为 0 ，并且旧阈值>0，说明之前创建了哈希表但没有添加元素，初始化容量等于阈值
        else if (oldThr > 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
         // 如果新的阈值为 0 ，就得用 新容量*加载因子 重计算一次
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?(int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        // 将底层链表数组 数据复制已经调整过大小的新链表数据
            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
```



#### Get

```java
    /**
     * 传入key值返回value值
     * 若不存在则返回null
     */ 
     public V get(Object key) {
        Node<K,V> e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }
    // 具体实现get-value 方法
     final Node<K,V> getNode(int hash, Object key) {
        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
        // 若表不为空且长度不为0 且指定位置hash表内有元素
        if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) {
        // 若key值相同 返回该节点
            if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))
                return first;
            // 若该节点有下一个节点 且该节点属于红黑树节点
            // 按照红黑树高效查找
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);
                // 直到下一个节点为空 循环 对比key值
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        // 若数组不存在hash算法的值 返回null
        return null;
    }
```



#### Remove

```java
    /**
     * 传入key 移除该key-value键值对
     * 若不存在 key 返回null
     */
    public V remove(Object key) {
        Node<K,V> e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
            null : e.value;
    }
    // 具体实现 remove - key 方法
    final Node<K,V> removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) {
        Node<K,V>[] tab; Node<K,V> p; int n, index;
         // 若表不为空且长度不为0 且指定位置hash表内有元素
        if ((tab = table) != null && (n = tab.length) > 0 && (p = tab[index = (n - 1) & hash]) != null) {
            Node<K,V> node = null, e; K k; V v;
            // 若key值相同 保留该节点
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                node = p;
            else if ((e = p.next) != null) {
                // 若该节点属于红黑树 按照红黑树查找方式 
                if (p instanceof TreeNode)
                    node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
                else {
                    // 循环链表直到链表为空 依次对比key 若相同 保留该节点
                    do {
                        if (e.hash == hash &&
                            ((k = e.key) == key ||
                             (key != null && key.equals(k)))) {
                            node = e;
                            break;
                        }
                        p = e;
                    } while ((e = e.next) != null);
                }
            }
            // 将该节点移除
            if (node != null && (!matchValue || (v = node.value) == value || (value != null && value.equals(v)))) {
                if (node instanceof TreeNode)
                    ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
                else if (node == p)
                    tab[index] = node.next;
                else
                    p.next = node.next;
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
        }
        // 若数组不存在hash算法的值 返回null
        return null;
    }
```

#### putAll

```java
    /**
     *  参数为map 要求key-value 
     *  对应的泛型要求 K -key（本类或子类）V -value（本类或子类）
     */
    public void putAll(Map<? extends K, ? extends V> m) {
        putMapEntries(m, true);
    }
    // 具体插入实现
    final void putMapEntries(Map<? extends K, ? extends V> m, boolean evict) {
        int s = m.size();
        if (s > 0) {
            // 若表为空 加载一些成员变量
            if (table == null) { // pre-size
                float ft = ((float)s / loadFactor) + 1.0F;
                int t = ((ft < (float)MAXIMUM_CAPACITY) ?
                         (int)ft : MAXIMUM_CAPACITY);
                if (t > threshold)
                    threshold = tableSizeFor(t);
            }
            // 重新调整大小
            else if (s > threshold)
                resize();
            // 依次遍历元素 插入数据
            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key), key, value, false, evict);
            }
        }
    }
```













### HashMap内部节点是有序的吗？

是无序的，根据hash值随机插入

LinkedHashMap 和 TreeMap是有序的

### LinkedHashMap怎么实现有序的？

 LinkedHashMap内部维护了一个单链表，有头尾节点，同时LinkedHashMap节点Entry内部除了继承HashMap的Node属性，还有before 和 after用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序。

```java
/**
 * The head (eldest) of the doubly linked list.
*/
transient LinkedHashMap.Entry<K,V> head;

/**
  * The tail (youngest) of the doubly linked list.
*/
transient LinkedHashMap.Entry<K,V> tail;
//链接新加入的p节点到链表后端
private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {
  LinkedHashMap.Entry<K,V> last = tail;
  tail = p;
  if (last == null)
    head = p;
  else {
    p.before = last;
    last.after = p;
  }
}
//LinkedHashMap的节点类
static class Entry<K,V> extends HashMap.Node<K,V> {
  Entry<K,V> before, after;
  Entry(int hash, K key, V value, Node<K,V> next) {
    super(hash, key, value, next);
  }
}

```

### TreeMap怎么实现有序的？

TreeMap是按照Key的自然顺序或者Comprator的顺序进行排序，内部是通过红黑树来实现。

所以要么key所属的类实现Comparable接口，或者自定义一个实现了Comparator接口的比较器，传给TreeMap用于key的比较



### HashMap总结

- hashmap基于哈希表的 map接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。

- 与hashtable区别是hashmap允许使用null作为key值，且线程不安全，hashtable不允许null作为key值线程安全，可以使用Collections.synchronizedMap使hashmap线程安全,

- 在JDK1.5后建议使用ConcurrentHashMap,ConcurrentHashMap采用锁分段机制，hashtable是一个线程访问时，其他线程无法访问，ConcurrentHashMap是一个线程访问某个指定数组的某一个下标，该下标所在段不允许其他线程访问，其他线程仍可访问ConcurrentHashMap的其他下标。

- hashmap底层数据结构是基于数组和链表（红黑树 ）来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。

  - 通过key值计算hash码值，将其传递进数组，若hash码值冲突则采用链表连接，
  - 若该hashmap容量大于64且该链表长度大于8则将该链表转化为红黑树，
  - 若链表长度减少到6时候，则将红黑树转化回链表

- hashmap每次扩容扩大为原来的两倍，扩容后原来的元素要么还在原来的位置, 要么移动到原来的位置+原来数组的长度的位置

  - ```java
    /**     * Initializes or doubles table size.  If null, allocates in     * accord with initial capacity target held in field threshold.     * Otherwise, because we are using power-of-two expansion, the     * elements from each bin must either stay at same index, or move     * with a power of two offset in the new table.     *     * @return the table     */    final Node<K,V>[] resize() {        Node<K,V>[] oldTab = table;        int oldCap = (oldTab == null) ? 0 : oldTab.length;        int oldThr = threshold;        int newCap, newThr = 0;        if (oldCap > 0) {            if (oldCap >= MAXIMUM_CAPACITY) {                threshold = Integer.MAX_VALUE;                return oldTab;            }            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&                     oldCap >= DEFAULT_INITIAL_CAPACITY)                newThr = oldThr << 1; // double threshold        }        else if (oldThr > 0) // initial capacity was placed in threshold            newCap = oldThr;        else {               // zero initial threshold signifies using defaults            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        }        if (newThr == 0) {            float ft = (float)newCap * loadFactor;            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?                      (int)ft : Integer.MAX_VALUE);        }        threshold = newThr;        @SuppressWarnings({"rawtypes","unchecked"})        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];        table = newTab;        if (oldTab != null) {            for (int j = 0; j < oldCap; ++j) {                Node<K,V> e;                if ((e = oldTab[j]) != null) {                    oldTab[j] = null;                    if (e.next == null)                        newTab[e.hash & (newCap - 1)] = e;                    else if (e instanceof TreeNode)                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);                    else { // preserve order                        Node<K,V> loHead = null, loTail = null;                        Node<K,V> hiHead = null, hiTail = null;                        Node<K,V> next;                        do {                            next = e.next;                            if ((e.hash & oldCap) == 0) {                                if (loTail == null)                                    loHead = e;                                else                                    loTail.next = e;                                loTail = e;                            }                            else {                                if (hiTail == null)                                    hiHead = e;                                else                                    hiTail.next = e;                                hiTail = e;                            }                        } while ((e = next) != null);                        if (loTail != null) {                            loTail.next = null;                            newTab[j] = loHead;                        }                        if (hiTail != null) {                            hiTail.next = null;                            newTab[j + oldCap] = hiHead;                        }                    }                }            }        }        return newTab;    }
    ```

  - 

## ConcurrentHashmap 与hashmap。 JDK1.7与JDK1.8的区别   

### HashMap

#### 数组+链表改成了数组+链表或红黑树；

1. 防止发生hash冲突，链表长度过长，将时间复杂度由`O(n)`降为`O(logn)`;

#### 链表的插入方式从头插法改成了尾插法，简单说就是插入时，

1. 如果数组位置上已经有元素，

   1. 1.7将新元素放到数组中，原始节点作为新节点的后继节点，
   2. 1.8遍历链表，将元素放置到链表的最后；

2. 因为1.7头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；

   1. A线程在插入节点B，B线程也在插入，遇到容量不够开始扩容，重新hash，放置元素，

   2. 采用头插法，后遍历到的B节点放入了头部，这样形成了环，如下图所示：

   3. <img src="数据结构.assets/image-20210727010702272.png" alt="image-20210727010702272" style="zoom:50%;" />

   4. 1.7的扩容调用transfer代码，如下所示：

   5. ```java
      void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;
        for (Entry<K,V> e : table) {
          while(null != e) {
            Entry<K,V> next = e.next;
            if (rehash) {
              e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            e.next = newTable[i]; //A线程如果执行到这一行挂起，B线程开始进行扩容
            newTable[i] = e;
            e = next;
          }
        }
      }
      ```



#### 扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小；

1. 扩容的时候为什么1.8 不用重新hash就可以直接定位原节点在新数据的位置呢?
   1. 这是由于扩容是扩大为原数组大小的2倍，用于计算数组位置的掩码仅仅只是高位多了一个1，怎么理解呢？
   2. 扩容前长度为16，用于计算(n-1) & hash 的二进制n-1为0000 1111，扩容为32后的二进制就高位多了1，为0001 1111。
   3. 因为是& 运算，1和任何数 & 都是它本身，那就分二种情况，如下图：原数据hashcode高位第4位为0和高位为1的情况；
   4. 第四位高位为0，重新hash数值不变，第四位为1，重新hash数值比原来大16（旧数组的容量）
   5. ![image-20210727011120677](数据结构.assets/image-20210727011120677.png)

#### 在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容；



### ConcurrentHashMap

- 数据结构：取消了 Segment 分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。
- 保证线程安全机制：JDK1.7 采用 Segment 的分段锁机制实现线程安全，其中 Segment 继承自 ReentrantLock 。JDK1.8 采用CAS+synchronized保证线程安全。
- 锁的粒度：JDK1.7 是对需要进行数据操作的 Segment 加锁，JDK1.8 调整为对每个数组元素加锁（Node）。
- 链表转化为红黑树：定位节点的 hash 算法简化会带来弊端，hash 冲突加剧，因此在链表节点数量大于 8（且数据总量大于等于 64）时，会将链表转化为红黑树进行存储。
- 查询时间复杂度：从 JDK1.7的遍历链表O(n)， JDK1.8 变成遍历红黑树O(logN)。





## ConcurrentHashMap

### ConcurrentHashMap 的实现原理是什么？ ★★★★★

ConcurrentHashMap 在 JDK1.7 和 JDK1.8 的实现方式是不同的。

#### 先来看下JDK1.7

- JDK1.7 中的 ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成，即 ConcurrentHashMap 把哈希桶数组切分成小数组（Segment ），每个小数组有 n 个 HashEntry 组成。

- 如下图所示，首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，实现了真正的并发访问。


![image-20210805125230033](数据结构.assets/image-20210805125230033.png)

##### Segment

Segment 是 ConcurrentHashMap 的一个内部类，

- Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色。Segment 默认为 16，也就是并发度为 16。

主要的组成如下：

![image-20210805125243477](数据结构.assets/image-20210805125243477.png)



##### HashEntry

存放元素的 HashEntry，也是一个静态内部类，

- 其中，用 volatile 修饰了 HashEntry 的数据 value 和 下一个节点 next，保证了多线程环境下数据获取时的可见性！

主要的组成如下：

![image-20210805125402007](数据结构.assets/image-20210805125402007.png)

#### 再来看下JDK1.8

- 在数据结构上， JDK1.8 中的ConcurrentHashMap 选择了与 HashMap 相同的Node数组+链表+红黑树结构；
- 在锁的实现上，抛弃了原有的 Segment 分段锁，采用CAS + synchronized实现更加细粒度的锁。
- 将锁的级别控制在了更细粒度的哈希桶数组元素级别，也就是说只需要锁住这个链表头节点（红黑树的根节点），就不会影响其他的哈希桶数组元素的读写，大大提高了并发度。


![image-20210805125451652](数据结构.assets/image-20210805125451652.png)

### JDK1.8 中为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock？★★★★★

- 在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁一步步转换。
- 减少内存开销 。假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。

### ConcurrentHashMap 的 put 方法执行逻辑是什么？★★★★

#### 先来看JDK1.7

首先会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。

- 尝试自旋获取锁。
- 如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。

![image-20210805125626503](数据结构.assets/image-20210805125626503.png)

先定位到相应的 Segment ，然后再进行 put 操作。

源代码如下：

![image-20210805125657153](数据结构.assets/image-20210805125657153.png)



#### 再来看JDK1.8

大致可以分为以下步骤：

1. 根据 key 计算出 hash 值；

2. 判断是否需要进行初始化；

3. 定位到 Node，拿到首节点 f，判断首节点 f：
   1. 如果为 null ，则通过 CAS 的方式尝试添加；
   2. 如果为 f.hash = MOVED = -1 ，说明其他线程在扩容，参与一起扩容；
   3. 如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入；
4. 当在链表长度达到 8 的时候，数组扩容或者将链表转换为红黑树。

源代码如下：

![image-20210805125825583](数据结构.assets/image-20210805125825583.png)

### ConcurrentHashMap 的 get 方法执行逻辑是什么？★★★★

#### 同样，先来看JDK1.7

首先，根据 key 计算出 hash 值定位到具体的 Segment ，再根据 hash 值获取定位 HashEntry 对象，并对 HashEntry 对象进行链表遍历，找到对应元素。

由于 HashEntry 涉及到的共享变量都使用 volatile 修饰，volatile 可以保证内存可见性，所以每次获取时都是最新值。

源代码如下：

![image-20210805125841156](数据结构.assets/image-20210805125841156.png)

#### 再来看JDK1.8

大致可以分为以下步骤：

1. 根据 key 计算出 hash 值，判断数组是否为空；

2. 如果是首节点，就直接返回；

3. 如果是红黑树结构，就从红黑树里面查询；

4. 如果是链表结构，循环遍历判断。


源代码如下：

![image-20210805125913795](数据结构.assets/image-20210805125913795.png)

### ConcurrentHashMap 的 get 方法是否要加锁，为什么？★★★

get 方法不需要加锁。因为 Node 的元素 value 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改节点的 value 或者新增节点的时候是对线程B可见的。

这也是它比其他并发集合比如 Hashtable、用 Collections.synchronizedMap()包装的 HashMap 效率高的原因之一。

![image-20210805125938597](数据结构.assets/image-20210805125938597.png)

### get 方法不需要加锁与 volatile 修饰的哈希桶数组有关吗？★★★

没有关系。哈希桶数组table用 volatile 修饰主要是保证在数组扩容的时候保证可见性。

![image-20210805125950801](数据结构.assets/image-20210805125950801.png)



### ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？★★★

- 我们先来说value 为什么不能为 null。因为 ConcurrentHashMap 是用于多线程的 ，如果ConcurrentHashMap.get(key)得到了 null ，这就无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，就有了二义性。

- 而用于单线程状态的 HashMap 却可以用containsKey(key) 去判断到底是否包含了这个 null 。


我们用反证法来推理：

- 假设 ConcurrentHashMap 允许存放值为 null 的 value，这时有A、B两个线程，线程A调用ConcurrentHashMap.get(key)方法，返回为 null ，我们不知道这个 null 是没有映射的 null ，还是存的值就是 null 。

- 假设此时，返回为 null 的真实情况是没有找到对应的 key。那么，我们可以用 ConcurrentHashMap.containsKey(key)来验证我们的假设是否成立，我们期望的结果是返回 false 。

- 但是在我们调用 ConcurrentHashMap.get(key)方法之后，containsKey方法之前，线程B执行了ConcurrentHashMap.put(key, null)的操作。那么我们调用containsKey方法返回的就是 true 了，这就与我们的假设的真实情况不符合了，这就有了二义性。

- 至于 ConcurrentHashMap 中的 key 为什么也不能为 null 的问题，源码就是这样写的，哈哈。如果面试官不满意，就回答因为作者Doug不喜欢 null ，所以在设计之初就不允许了 null 的 key 存在。


### ConcurrentHashMap 的并发度是什么？★★

并发度可以理解为程序运行时能够同时更新 ConccurentHashMap且不产生锁竞争的最大线程数。在JDK1.7中，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度，默认是16，这个值可以在构造函数中设置。

如果自己设置了并发度，ConcurrentHashMap 会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32。

如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。

在JDK1.8中，已经摒弃了Segment的概念，选择了Node数组+链表+红黑树结构，并发度大小依赖于数组的大小。

#### ConcurrentHashMap 迭代器是强一致性还是弱一致性？★★

与 HashMap 迭代器是强一致性不同，ConcurrentHashMap 迭代器是弱一致性。

ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。

这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。

#### JDK1.7 与 JDK1.8 中ConcurrentHashMap 的区别？★★★★★

- 数据结构：取消了 Segment 分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。
- 保证线程安全机制：JDK1.7 采用 Segment 的分段锁机制实现线程安全，其中 Segment 继承自 ReentrantLock 。JDK1.8 采用CAS+synchronized保证线程安全。
- 锁的粒度：JDK1.7 是对需要进行数据操作的 Segment 加锁，JDK1.8 调整为对每个数组元素加锁（Node）。
- 链表转化为红黑树：定位节点的 hash 算法简化会带来弊端，hash 冲突加剧，因此在链表节点数量大于 8（且数据总量大于等于 64）时，会将链表转化为红黑树进行存储。
- 查询时间复杂度：从 JDK1.7的遍历链表O(n)， JDK1.8 变成遍历红黑树O(logN)。

#### ConcurrentHashMap 和 Hashtable 的效率哪个更高？为什么？★★★★★

ConcurrentHashMap 的效率要高于 Hashtable，因为 Hashtable 给整个哈希表加了一把大锁从而实现线程安全。

而ConcurrentHashMap 的锁粒度更低，在 JDK1.7 中采用分段锁实现线程安全，在 JDK1.8 中采用CAS+synchronized实现线程安全。

#### 具体说一下Hashtable的锁机制 ★★★★★

Hashtable 是使用 synchronized来实现线程安全的，给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放，在竞争激烈的多线程场景中性能就会非常差！

![image-20210805130138727](数据结构.assets/image-20210805130138727.png)

#### 多线程下安全的操作 map还有其他方法吗？★★★

还可以使用Collections.synchronizedMap方法，对方法进行加同步锁。

如果传入的是 HashMap 对象，其实也是对 HashMap 做的方法做了一层包装，里面使用对象锁来保证多线程场景下，线程安全，本质也是对 HashMap 进行全表锁。**在竞争激烈的多线程环境下性能依然也非常差，不推荐使用！**

![image-20210805130154958](数据结构.assets/image-20210805130154958.png)



## TreeMap

### TreeMap介绍

- TreeMap 是一个**有序的key-value集合**，它是通过[红黑树](http://www.cnblogs.com/skywang12345/p/3245399.html)实现的。
- TreeMap **继承于AbstractMap**，所以它是一个Map，即一个key-value集合。
- TreeMap 实现了NavigableMap接口，意味着它**支持一系列的导航方法。**比如返回有序的key集合。
- TreeMap 实现了Cloneable接口，意味着**它能被克隆**。
- TreeMap 实现了java.io.Serializable接口，意味着**它支持序列化**。
- TreeMap基于**红黑树（Red-Black tree）实现**。该映射根据**其键的自然顺序进行排序**，或者根据**创建映射时提供的 Comparator 进行排序**，具体取决于使用的构造方法。
- TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。
- 另外，TreeMap是**非同步**的。 它的iterator 方法返回的**迭代器是fail-fastl**的。

### ***\*TreeMap的构造函数\****

```java
// 默认构造函数。使用该构造函数，TreeMap中的元素按照自然排序进行排列。
TreeMap()
 
// 创建的TreeMap包含Map
TreeMap(Map<? extends K, ? extends V> copyFrom)
 
// 指定Tree的比较器
TreeMap(Comparator<? super K> comparator)
 
// 创建的TreeSet包含copyFrom
TreeMap(SortedMap<K, ? extends V> copyFrom)
```



### ***\*TreeMap的API\****

```java
 Map.Entry<K,V>	ceilingEntry(K key) 
          返回一个键-值映射关系，它与大于等于给定键的最小键关联；如果不存在这样的键，则返回 null。
 K	ceilingKey(K key) 
          返回大于等于给定键的最小键；如果不存在这样的键，则返回 null。
 void	clear() 
          从此映射中移除所有映射关系。
 Object	clone() 
          返回此 TreeMap 实例的浅表副本。
 Comparator<? super K>	comparator() 
          返回对此映射中的键进行排序的比较器；如果此映射使用键的自然顺序，则返回 null。
 boolean	containsKey(Object key) 
          如果此映射包含指定键的映射关系，则返回 true。
 boolean	containsValue(Object value) 
          如果此映射为指定值映射一个或多个键，则返回 true。
 NavigableSet<K>	descendingKeySet() 
          返回此映射中所包含键的逆序 NavigableSet 视图。
 NavigableMap<K,V>	descendingMap() 
          返回此映射中所包含映射关系的逆序视图。
 Set<Map.Entry<K,V>>	entrySet() 
          返回此映射中包含的映射关系的 Set 视图。
 Map.Entry<K,V>	firstEntry() 
          返回一个与此映射中的最小键关联的键-值映射关系；如果映射为空，则返回 null。
 K	firstKey() 
          返回此映射中当前第一个（最低）键。
 Map.Entry<K,V>	floorEntry(K key) 
          返回一个键-值映射关系，它与小于等于给定键的最大键关联；如果不存在这样的键，则返回 null。
 K	floorKey(K key) 
          返回小于等于给定键的最大键；如果不存在这样的键，则返回 null。
 V	get(Object key) 
          返回指定键所映射的值，如果对于该键而言，此映射不包含任何映射关系，则返回 null。
 SortedMap<K,V>	headMap(K toKey) 
          返回此映射的部分视图，其键值严格小于 toKey。
 NavigableMap<K,V>	headMap(K toKey, boolean inclusive) 
          返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。
 Map.Entry<K,V>	higherEntry(K key) 
          返回一个键-值映射关系，它与严格大于给定键的最小键关联；如果不存在这样的键，则返回 null。
 K	higherKey(K key) 
          返回严格大于给定键的最小键；如果不存在这样的键，则返回 null。
 Set<K>	keySet() 
          返回此映射包含的键的 Set 视图。
 Map.Entry<K,V>	lastEntry() 
          返回与此映射中的最大键关联的键-值映射关系；如果映射为空，则返回 null。
 K	lastKey() 
          返回映射中当前最后一个（最高）键。
 Map.Entry<K,V>	lowerEntry(K key) 
          返回一个键-值映射关系，它与严格小于给定键的最大键关联；如果不存在这样的键，则返回 null。
 K	lowerKey(K key) 
          返回严格小于给定键的最大键；如果不存在这样的键，则返回 null。
 NavigableSet<K>	navigableKeySet() 
          返回此映射中所包含键的 NavigableSet 视图。
 Map.Entry<K,V>	pollFirstEntry() 
          移除并返回与此映射中的最小键关联的键-值映射关系；如果映射为空，则返回 null。
 Map.Entry<K,V>	pollLastEntry() 
          移除并返回与此映射中的最大键关联的键-值映射关系；如果映射为空，则返回 null。
 V	put(K key, V value) 
          将指定值与此映射中的指定键进行关联。
 void	putAll(Map<? extends K,? extends V> map) 
          将指定映射中的所有映射关系复制到此映射中。
 V	remove(Object key) 
          如果此 TreeMap 中存在该键的映射关系，则将其删除。
 int	size() 
          返回此映射中的键-值映射关系数。
 NavigableMap<K,V>	subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) 
          返回此映射的部分视图，其键的范围从 fromKey 到 toKey。
 SortedMap<K,V>	subMap(K fromKey, K toKey) 
          返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。
 SortedMap<K,V>	tailMap(K fromKey) 
          返回此映射的部分视图，其键大于等于 fromKey。
 NavigableMap<K,V>	tailMap(K fromKey, boolean inclusive) 
          返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。
 Collection<V>	values() 
          返回此映射包含的值的 Collection 视图。
```

### ***\*TreeMap数据结构\****

#### **TreeMap的继承关系**

```java
java.lang.Object
   ↳     java.util.AbstractMap<K, V>
         ↳     java.util.TreeMap<K, V>
 
public class TreeMap<K,V>
    extends AbstractMap<K,V>
    implements NavigableMap<K,V>, Cloneable, java.io.Serializable {}
```

#### **TreeMap与Map关系如下图：**

![image-20210805134321990](数据结构.assets/image-20210805134321990.png)



TreeMap的实现是红黑树算法的实现，

1. 红黑树的基本概念。
2. 红黑树增加节点. 删除节点的实现过程。
3. 红黑树左旋转. 右旋转的复杂过程。
4. Java 中TreeMap是如何通过put. deleteEntry两个来实现红黑树增加. 删除节点的。



### 一. 红黑树简介

红黑树又称红-黑二叉树，它首先是一颗二叉树，它具体二叉树所有的特性。同时红黑树更是一颗自平衡的排序二叉树。

我们知道一颗基本的二叉树满足一个基本性质--

- 即树中的任何节点的值大于它的左子节点，且小于它的右子节点。

按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右/左子树），这样势必会导致二叉树的检索效率大大降低（O(n)），所以为了维持二叉树的平衡，大牛们提出了各种实现的算法，如：[AVL](http://baike.baidu.com/view/414610.htm)，[SBT](http://baike.baidu.com/view/2957252.htm)，[伸展树](http://baike.baidu.com/view/1118088.htm)，[TREAP](http://baike.baidu.com/view/956602.htm) ，[红黑树](http://baike.baidu.com/view/133754.htm?fr=aladdin#1_1)等等。

平衡二叉树必须具备如下特性：

- 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，
- 并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。

![image-20210805134658132](数据结构.assets/image-20210805134658132.png)

红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树二叉树而言我们必须增加如下规则：

- 1. 每个节点都只能是红色或者黑色 
- 2. 根节点是黑色 
- 3. 每个叶节点（NIL节点，空节点）是黑色的。 
- 4. 如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。 
- 5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

这些约束强制了红黑树的关键性质: 

- 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这棵树大致上是平衡的。
- 因为操作比如插入. 删除和查找某个值的最坏情况时间都要求与树的高度成比例，
- 这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。
- 所以红黑树它是复杂而高效的，其检索效率O(log *n*)。下图为一颗典型的红黑二叉树。

![image-20210805134709782](数据结构.assets/image-20210805134709782.png)

对于红黑二叉树而言它主要包括三大基本操作：左旋. 右旋. 着色。

![202107232218323703.png](https://www.cmsblogs.com/images/group/java-advance/java-tigao/202107232218323703.png)

![202107232218335384.png](https://www.cmsblogs.com/images/group/java-advance/java-tigao/202107232218335384.png)

（图片来自：http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html）

------

本节参考文献：http://baike.baidu.com/view/133754.htm?fr=aladdin-----百度百科

**注：**由于本文主要是讲解Java中TreeMap，所以并没有对红黑树进行非常深入的了解和研究，如果诸位想对其进行更加深入的研究Lz提供几篇较好的博文：

**1. [红黑树系列集锦](http://blog.csdn.net/v_JULY_v/article/category/774945)**

**2. [红黑树数据结构剖析](http://www.cnblogs.com/fanzhidongyzby/p/3187912.html)**

**3. [红黑树](http://blog.csdn.net/eric491179912/article/details/6179908)**

### 二. TreeMap数据结构

TreeMap的定义如下：

```java
public class TreeMap<K,V>
    extends AbstractMap<K,V>
    implements NavigableMap<K,V>, Cloneable, java.io.Serializable

```

TreeMap继承AbstractMap，实现NavigableMap. Cloneable. Serializable三个接口。

其中AbstractMap表明TreeMap为一个Map即支持key-value的集合， 

NavigableMap（[更多](http://docs.oracle.com/javase/7/docs/api/java/util/NavigableMap.html)）则意味着它支持一系列的导航方法，具备针对给定搜索目标返回最接近匹配项的导航方法 。

TreeMap中同时也包含了如下几个重要的属性：

```java
//比较器，因为TreeMap是有序的，通过comparator接口我们可以对TreeMap的内部排序进行精密的控制
private final Comparator<? super K> comparator;
//TreeMap红-黑节点，为TreeMap的内部类
private transient Entry<K,V> root = null;
//容器大小
private transient int size = 0;
//TreeMap修改次数
private transient int modCount = 0;
//红黑树的节点颜色--红色
private static final boolean RED = false;
//红黑树的节点颜色--黑色
private static final boolean BLACK = true;
```

对于叶子节点Entry是TreeMap的内部类，它有几个重要的属性：

```java
//键
K key;
//值
V value;
//左孩子
Entry<K,V> left = null;
//右孩子
Entry<K,V> right = null;
//父亲
Entry<K,V> parent;
//颜色
boolean color = BLACK;
```



### 三. TreeMap put()方法

在了解TreeMap的put()方法之前，我们先了解红黑树增加节点的算法。

#### 红黑树增加节点

红黑树在新增节点过程中比较复杂，复杂归复杂它同样必须要依据上面提到的五点规范，同时由于规则1. 2. 3基本都会满足，下面我们主要讨论规则4. 5。假设我们这里有一棵最简单的树，我们规定新增的节点为N. 它的父节点为P. P的兄弟节点为U. P的父节点为G。

![image-20210805134838330](数据结构.assets/image-20210805134838330.png)

对于新节点的插入有如下三个关键地方：

1. 插入新节点总是红色节点 。
2. 如果插入节点的父节点是黑色, 能维持性质 。
3. 如果插入节点的父节点是红色, 破坏了性质. 故插入算法就是通过重新着色或旋转, 来维持性质 。

##### **一. 插入为根节点** 

- 若新插入的节点N没有父节点，则直接当做根据节点插入即可，同时将颜色设置为黑色。（如图一（1））

##### **二. 父节点为黑色**

这种情况新节点N同样是直接插入，同时颜色为红色，由于根据规则四它会存在两个黑色的叶子节点，值为null。同时由于新增节点N为红色，所以通过它的子节点的路径依然会保存着相同的黑色节点数，同样满足规则5。（如图一（2））

![image-20210805134852467](数据结构.assets/image-20210805134852467.png)

（图一）

**三. 若父节点P和P的兄弟节点U都为红色**

对于这种情况若直接插入肯定会出现不平衡现象。怎么处理？

- P. U节点变黑. G节点变红。
- 这时由于经过节点P. U的路径都必须经过G所以在这些路径上面的黑节点数目还是相同的。但是经过上面的处理，可能G节点的父节点也是红色，这个时候我们需要将G节点当做新增节点递归处理。

![202107232218348007.png](https://www.cmsblogs.com/images/group/java-advance/java-tigao/202107232218348007.png)

##### 四. 若父节点P为红色，叔父节点U为黑色或者缺少，且新增节点N为P节点的右孩子

对于这种情况

- 我们对新增节点N. P进行一次左旋转。
- 这里所产生的结果其实并没有完成，还不是平衡的（违反了规则四），这是我们需要进行情况5的操作。

![202107232218349968.png](https://www.cmsblogs.com/images/group/java-advance/java-tigao/202107232218349968.png)

##### 五. 父节点P为红色，叔父节点U为黑色或者缺少，新增节点N为父节点P左孩子

这种情况有可能是由于情况四而产生的，也有可能不是。对于这种情况

- 先以P节点为中心进行右旋转，在旋转后产生的树中，节点P是节点N. G的父节点。
- 但是这棵树并不规范，它违反了规则4，所以我们将P. G节点的颜色进行交换，使之其满足规范。
- 开始时所有的路径都需要经过G其他们的黑色节点数一样，但是现在所有的路径改为经过P，且P为整棵树的唯一黑色节点，所以调整后的树同样满足规范5。

![202107232218352129.png](https://www.cmsblogs.com/images/group/java-advance/java-tigao/202107232218352129.png)

上面展示了红黑树新增节点的五种情况，这五种情况涵盖了所有的新增可能，不管这棵红黑树多么复杂，都可以根据这五种情况来进行生成。下面就来分析Java中的TreeMap是如何来实现红黑树的。

#### TreeMap put()方法实现分析

在TreeMap的put()的实现方法中主要分为两个步骤，第一：构建排序二叉树，第二：平衡二叉树。

对于排序二叉树的创建，其添加节点的过程如下：

1. 以根节点为初始节点进行检索。
2. 与当前节点进行比对，若新增节点值较大，则以当前节点的右子节点作为新的当前节点。否则以当前节点的左子节点作为新的当前节点。
3. 循环递归2步骤知道检索出合适的叶子节点为止。
4. 将新增节点与3步骤中找到的节点进行比对，如果新增节点较大，则添加为右子节点；否则添加为左子节点。

按照这个步骤我们就可以将一个新增节点添加到排序二叉树中合适的位置。如下：

```java
public V put(K key, V value) {
    //用t表示二叉树的当前节点
    Entry<K,V> t = root;
    //t为null表示一个空树，即TreeMap中没有任何元素，直接插入
    if (t == null) {
        //比较key值，个人觉得这句代码没有任何意义，空树还需要比较. 排序？
        compare(key, key); // type (and possibly null) check
        //将新的key-value键值对创建为一个Entry节点，并将该节点赋予给root
        root = new Entry<>(key, value, null);
        //容器的size = 1，表示TreeMap集合中存在一个元素
        size = 1;
        //修改次数 + 1
        modCount++;
        return null;
    }
    int cmp;     //cmp表示key排序的返回结果
    Entry<K,V> parent;   //父节点
    // split comparator and comparable paths
    Comparator<? super K> cpr = comparator;    //指定的排序算法
    //如果cpr不为空，则采用既定的排序算法进行创建TreeMap集合
    if (cpr != null) {
        do {
            **parent** **= t;      //****parent指向上次循环后的t
            //比较新增节点的key和当前节点key的大小
            cmp =** **cpr.compare(key, t.key);
            //cmp返回值小于0，表示新增节点的key小于当前节点的key，则以当前节点的左子节点作为新的当前节点
            if (cmp < 0****)
                t =** **t.left;
            //cmp返回值大于0，表示新增节点的key大于当前节点的key，则以当前节点的右子节点作为新的当前节点
            else if (cmp > 0****)
                t =** **t.right;
            //cmp返回值等于0，表示两个key值相等，则新值覆盖旧值，并返回新值
            else
                return** **t.setValue(value);**
        } while (t != null);
    }
    //如果cpr为空，则采用默认的排序算法进行创建TreeMap集合
    else {
        if (key == null)     //key值为空抛出异常
            throw new NullPointerException();
        /* 下面处理过程和上面一样 */
        Comparable<? super K> k = (Comparable<? super K>) key;
        do {
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    //将新增节点当做parent的子节点
    Entry<K,V> e = new Entry<>(key, value, parent);
    //如果新增节点的key小于parent的key，则当做左子节点
    if (cmp < 0)
        parent.left = e;
    //如果新增节点的key大于parent的key，则当做右子节点
    else
        parent.right = e;
    /*
                     *  上面已经完成了排序二叉树的的构建，将新增节点插入该树中的合适位置
                     *  下面fixAfterInsertion()方法就是对这棵树进行调整. 平衡，具体过程参考上面的五种情况
                     */
    **fixAfterInsertion(e);**
        //TreeMap元素数量 + 1
        size++;
    //TreeMap容器修改次数 + 1
    modCount++;
    return null;
}
```

上面代码中do{}代码块是实现排序二叉树的核心算法，通过该算法我们可以确认新增节点在该树的正确位置。找到正确位置后将插入即可，这样做了其实还没有完成，因为我知道TreeMap的底层实现是红黑树，红黑树是一棵平衡排序二叉树，普通的排序二叉树可能会出现失衡的情况，所以下一步就是要进行调整。fixAfterInsertion(e); 调整的过程务必会涉及到红黑树的左旋. 右旋. 着色三个基本操作。代码如下：

```java
/**
             * 新增节点后的修复操作
             * x 表示新增节点
             */
private void fixAfterInsertion(Entry<K,V> x) {
    x.color = RED;    //新增节点的颜色为红色

    //循环 直到 x不是根节点，且x的父节点不为红色
    while (x != null && x != root && x.parent.color == RED) {
        //如果X的父节点（P）是其父节点的父节点（G）的左节点
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
            //获取X的叔节点(U)
            Entry<K,V> y = rightOf(parentOf(parentOf(x)));
            **//如果X的叔节点（U） 为红色（情况三）**
                if (colorOf(y) == RED) {     
                    //将X的父节点（P）设置为黑色
                    setColor(parentOf(x), BLACK);
                    //将X的叔节点（U）设置为黑色
                    setColor(y, BLACK);
                    //将X的父节点的父节点（G）设置红色
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                }
            **//如果X的叔节点（U为黑色）；这里会存在两种情况（情况四. 情况五）**
                else {   
                    **//如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）**
                        if (x == rightOf(parentOf(x))) {
                            //将X的父节点作为X
                            x = parentOf(x);
                            //右旋转
                            rotateLeft(x);
                        }
                    **//****（情况五）**
                        **//将X的父节点（P）设置为黑色**
                        setColor(parentOf(x), BLACK);
                    //将X的父节点的父节点（G）设置红色
                    setColor(parentOf(parentOf(x)), RED);
                    //以X的父节点的父节点（G）为中心右旋转
                    rotateRight(parentOf(parentOf(x)));
                }
        }
        //如果X的父节点（P）是其父节点的父节点（G）的右节点
        else {
            //获取X的叔节点（U）
            Entry<K,V> y = leftOf(parentOf(parentOf(x)));
            //如果X的叔节点（U） 为红色（情况三）
            if (colorOf(y) == RED) {
                //将X的父节点（P）设置为黑色
                setColor(parentOf(x), BLACK);
                //将X的叔节点（U）设置为黑色
                setColor(y, BLACK);
                //将X的父节点的父节点（G）设置红色
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            }
            //如果X的叔节点（U为黑色）；这里会存在两种情况（情况四. 情况五）
            else {
                //如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）
                if (x == leftOf(parentOf(x))) {
                    //将X的父节点作为X
                    x = parentOf(x);
                    //右旋转
                    rotateRight(x);
                }
                //（情况五）
                //将X的父节点（P）设置为黑色
                setColor(parentOf(x), BLACK);
                //将X的父节点的父节点（G）设置红色
                setColor(parentOf(parentOf(x)), RED);
                //以X的父节点的父节点（G）为中心右旋转
                rotateLeft(parentOf(parentOf(x)));
            }
        }
    }
    //将根节点G强制设置为黑色
    root.color = BLACK;
}
```



对这段代码的研究我们发现,其处理过程完全符合红黑树新增节点的处理过程。所以在看这段代码的过程一定要对红黑树的新增节点过程有了解。在这个代码中还包含几个重要的操作。左旋(rotateLeft()). 右旋（rotateRight()）. 着色（setColor()）。

#### 左旋：rotateLeft()

所谓左旋转，就是将新增节点（N）当做其父节点（P），将其父节点P当做新增节点（N）的左子节点。即：G.left ---> N ,N.left ---> P。

```java
private void rotateLeft(Entry<K,V> p) {
    if (p != null) {
        //获取P的右子节点，其实这里就相当于新增节点N（情况四而言）
        Entry<K,V> r = p.right;
        //将R的左子树设置为P的右子树
        p.right = r.left;
        //若R的左子树不为空，则将P设置为R左子树的父亲
        if (r.left != null)
            r.left.parent = p;
        //将P的父亲设置R的父亲
        r.parent = p.parent;
        //如果P的父亲为空，则将R设置为跟节点
        if (p.parent == null)
            root = r;
        //如果P为其父节点（G）的左子树，则将R设置为P父节点(G)左子树
        else if (p.parent.left == p)
            p.parent.left = r;
        //否则R设置为P的父节点（G）的右子树
        else
            p.parent.right = r;
        //将P设置为R的左子树
        r.left = p;
        //将R设置为P的父节点
        p.parent = r;
    }
}
```

#### 右旋：rotateRight()

所谓右旋转即，P.right ---> G. G.parent ---> P。

```java
private void rotateRight(Entry<K,V> p) {
    if (p != null) {
        //将L设置为P的左子树
        Entry<K,V> l = p.left;
        //将L的右子树设置为P的左子树
        p.left = l.right;
        //若L的右子树不为空，则将P设置L的右子树的父节点
        if (l.right != null)
            l.right.parent = p;
        //将P的父节点设置为L的父节点
        l.parent = p.parent;
        //如果P的父节点为空，则将L设置根节点
        if (p.parent == null)
            root = l;
        //若P为其父节点的右子树，则将L设置为P的父节点的右子树
        else if (p.parent.right == p)
            p.parent.right = l;
        //否则将L设置为P的父节点的左子树
        else
            p.parent.left = l;
        //将P设置为L的右子树
        l.right = p;
        //将L设置为P的父节点
        p.parent = l;
    }
}
```

![2021072322183542010.png](https://www.cmsblogs.com/images/group/java-advance/java-tigao/2021072322183542010.png)

![2021072322183632211.png](https://www.cmsblogs.com/images/group/java-advance/java-tigao/2021072322183632211.png)

（图片来自：http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html）

#### 着色：setColor()

着色就是改变该节点的颜色，在红黑树中，它是依靠节点的颜色来维持平衡的。

```java
private static <K,V> void setColor(Entry<K,V> p, boolean c) {
    if (p != null)
        p.color = c;
}
```

### 四. TreeMap delete()方法

#### 红黑树删除节点

针对于红黑树的增加节点而言，删除显得更加复杂，同时删除节点和增加节点一样，同样是找到删除的节点，删除之后调整红黑树。

但是这里的删除节点并不是直接删除，而是通过走了“弯路”通过一种捷径来删除的：

- 找到被删除的节点D的子节点C，用C来替代D，不是直接删除D，因为D被C替代了，直接删除C即可。
- 所以这里就将删除父节点D的事情转变为了删除子节点C的事情，这样处理就将复杂的删除事件简单化了。
- 子节点C的规则是：右分支最左边，或者 左分支最右边的。

![image-20210805135815760](数据结构.assets/image-20210805135815760.png)

红-黑二叉树删除节点，最大的麻烦是要保持 各分支黑色节点数目相等。 因为是删除，所以不用担心存在颜色冲突问题——插入才会引起颜色冲突。

红黑树删除节点同样会分成几种情况，这里是按照待删除节点有几个儿子的情况来进行分类：

1. 没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。
2. 只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。
3. 有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。

诚然，既然删除节点比较复杂，那么在这里我们就约定一下规则：

1. 下面要讲解的删除节点一定是实际要删除节点的后继节点（N），如前面提到的C。
2. 下面提到的删除节点的树都是如下结构，该结构所选取的节点是待删除节点的右树的最左边子节点。这里我们规定真实删除节点为N. 父节点为P. 兄弟节点为W兄弟节点的两个子节点为X1. X2。如下图（2.1）。

![image-20210805135957392](数据结构.assets/image-20210805135957392.png)

现在我们就上面提到的三种情况进行分析. 处理。

#### **情况一. 无子节点（红色节点）**

这种情况对该节点直接删除即可，不会影响树的结构。因为该节点为叶子节点它不可能存在子节点-----如子节点为黑，则违反黑节点数原则（规定5），为红，则违反“颜色”原则（规定4）。 如上图（2.2）。

#### **情况二. 有一个子节点**

这种情况处理也是非常简单的，用子节点替代待删除节点，然后删除子节点即可。如上图（2.3）

#### **情况三. 有两个子节点**

这种情况可能会稍微有点儿复杂。它需要找到一个替代待删除节点（N）来替代它，然后删除N即可。它主要分为四种情况。

1. N的兄弟节点W为红色
2. N的兄弟w是黑色的，且w的俩个孩子都是黑色的。
3. N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。
4. N的兄弟w是黑色的，且w的右孩子时红色的。

##### **情况3.1. N的兄弟节点W为红色**

W为红色，那么其子节点X1. X2必定全部为黑色，父节点P也为黑色。处理策略是：改变W. P的颜色，然后进行一次左旋转。这样处理就可以使得红黑性质得以继续保持。N的新兄弟new w是旋转之前w的某个孩子，为黑色。这样处理后将情况3.1. 转变为3.2. 3.3. 3.4中的一种。如下：

![image-20210805140159308](数据结构.assets/image-20210805140159308.png)

##### **情况3.2. N的兄弟w是黑色的，且w的俩个孩子都是黑色的。**

这种情况其父节点可红可黑，由于W为黑色，这样导致N子树相对于其兄弟W子树少一个黑色节点，这时我们可以将W置为红色。这样，N子树与W子树黑色节点一致，保持了平衡。如下

![image-20210805140353701](数据结构.assets/image-20210805140353701.png)

将W由黑转变为红，这样就会导致新节点new N相对于它的兄弟节点会少一个黑色节点。但是如果new x为红色，我们直接将new x转变为黑色，保持整棵树的平衡。否则情况3.2 会转变为情况3.1. 3.3. 3.4中的一种。

##### **情况3.3. N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。**

针对这种情况是将节点W和其左子节点进行颜色交换，然后对W进行右旋转处理。

![image-20210805140301700](数据结构.assets/image-20210805140301700.png)

此时N的新兄弟X1(new w)是一个有红色右孩子的黑结点，于是将情况3转化为情况4.

##### **情况3.4. N的兄弟w是黑色的，且w的右孩子时红色的。**

交换W和父节点P的颜色，同时对P进行左旋转操作。这样就把左边缺失的黑色节点给补回来了。同时将W的右子节点X2置黑。这样左右都达到了平衡。

![image-20210805140340507](数据结构.assets/image-20210805140340507.png)

**总结**

个人认为这四种情况比较难理解，首先他们都不是单一的某种情况，他们之间是可以进行互转的。相对于其他的几种情况，

- 情况3.2比较好理解，仅仅只是一个颜色的转变，通过减少右子树的一个黑色节点使之保持平衡，同时将不平衡点上移至N与W的父节点，然后进行下一轮迭代。
- 情况3.1，是将W旋转将其转成情况2. 3. 4情况进行处理。
- 而情况3.3通过转变后可以化成情况3.4来进行处理，从这里可以看出情况3.4应该最终结。
- 况3.4. 右子节点为红色节点，那么将缺失的黑色节点交由给右子节点，通过旋转达到平衡。

通过上面的分析，我们已经初步了解了红黑树的删除节点情况，相对于增加节点而言它确实是选的较为复杂。下面我将看到在Java TreeMap中是如何实现红黑树删除的。

#### TreeMap deleteEntry()方法实现分析

通过上面的分析我们确认删除节点的步骤是：找到一个替代子节点C来替代P，然后直接删除C，最后调整这棵红黑树。下面代码是寻找替代节点. 删除替代节点。

```java
private void deleteEntry(Entry<K,V> p) {
    modCount++;      //修改次数 +1
    size--;          //元素个数 -1

    *  /***
     *** 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点
             * successor(P)方法为寻找P的替代节点。规则是右分支最左边，或者 左分支最右边的节点
             * ---------------------（1）** ***/**
        if (p.left != null && p.right != null) {  
            Entry<K,V> s = successor(p);
            p.key = s.key;
            p.value = s.value;
            p = s;
        }

    //replacement为替代节点，如果P的左子树存在那么就用左子树替代，否则用右子树替代
    Entry<K,V> replacement = (p.left != null ? p.left : p.right);

    **/***
     *** 删除节点，分为上面提到的三种情况
             * -----------------------（2）** ***/**
        //如果替代节点不为空
        if (replacement != null) {
            replacement.parent = p.parent;
            /*
                 *replacement来替代P节点
                 */
            //若P没有父节点，则跟节点直接变成replacement
            if (p.parent == null)
                root = replacement;
            //如果P为左节点，则用replacement来替代为左节点
            else if (p == p.parent.left)
                p.parent.left  = replacement;
            //如果P为右节点，则用replacement来替代为右节点
            else
                p.parent.right = replacement;

            //同时将P节点从这棵树中剔除掉
            p.left = p.right = p.parent = null;

            /*
                 * 若P为红色直接删除，红黑树保持平衡
                 * 但是若P为黑色，则需要调整红黑树使其保持平衡
                 */
            if (p.color == BLACK)
                fixAfterDeletion(replacement);
        } else if (p.parent == null) {     //p没有父节点，表示为P根节点，直接删除即可
            root = null;
        } else {      //P节点不存在子节点，直接删除即可
            if (p.color == BLACK)         //如果P节点的颜色为黑色，对红黑树进行调整
                fixAfterDeletion(p);

            //删除P节点
            if (p.parent != null) {
                if (p == p.parent.left)
                    p.parent.left = null;
                else if (p == p.parent.right)
                    p.parent.right = null;
                p.parent = null;
            }
        }
}
```

**（1）** 除是寻找替代节点replacement，其实现方法为successor()。如下：

```java
static <K,V> TreeMap.Entry<K,V> successor(Entry<K,V> t) {
    if (t == null)
        return null;
    /*
             * 寻找右子树的最左子树
             */
    else if (t.right != null) {
        Entry<K,V> p = t.right;
        while (p.left != null)
            p = p.left;
        return p;
    }
    /*
             * 选择左子树的最右子树
             */
    else {
        Entry<K,V> p = t.parent;
        Entry<K,V> ch = t;
        while (p != null && ch == p.right) {
            ch = p;
            p = p.parent;
        }
        return p;
    }
}
```

**（2）** 处是删除该节点过程。它主要分为上面提到的三种情况，它与上面的if…else if… else一一对应 。如下：

1. 有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。
2. 没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。
3. 只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。

删除完节点后，就要根据情况来对红黑树进行复杂的调整：fixAfterDeletion()。

```java
private void fixAfterDeletion(Entry<K,V> x) {
    // 删除节点需要一直迭代，知道 直到 x 不是根节点，且 x 的颜色是黑色
    while (x != root && colorOf(x) == BLACK) {
        if (x == leftOf(parentOf(x))) {      //若X节点为左节点
            //获取其兄弟节点
            Entry<K,V> sib = rightOf(parentOf(x));

            /*
                     * 如果兄弟节点为红色----（情况3.1）
                     * 策略：改变W. P的颜色，然后进行一次左旋转
                     */
            if (colorOf(sib) == RED) {     
                setColor(sib, BLACK);     
                setColor(parentOf(x), RED);  
                rotateLeft(parentOf(x));
                sib = rightOf(parentOf(x));
            }

            /*
                     * 若兄弟节点的两个子节点都为黑色----（情况3.2）
                     * 策略：将兄弟节点编程红色
                     */
            if (colorOf(leftOf(sib))  == BLACK &&
                colorOf(rightOf(sib)) == BLACK) {
                setColor(sib, RED);
                x = parentOf(x);
            }
            else {
                /*
                         * 如果兄弟节点只有右子树为黑色----（情况3.3）
                         * 策略：将兄弟节点与其左子树进行颜色互换然后进行右转
                         * 这时情况会转变为3.4
                         */
                if (colorOf(rightOf(sib)) == BLACK) {
                    setColor(leftOf(sib), BLACK);
                    setColor(sib, RED);
                    rotateRight(sib);
                    sib = rightOf(parentOf(x));
                }
                /*
                         *----情况3.4
                         *策略：交换兄弟节点和父节点的颜色，
                         *同时将兄弟节点右子树设置为黑色，最后左旋转
                         */
                setColor(sib, colorOf(parentOf(x)));
                setColor(parentOf(x), BLACK);
                setColor(rightOf(sib), BLACK);
                rotateLeft(parentOf(x));
                x = root;
            }
        }

        /**
                 * X节点为右节点与其为做节点处理过程差不多，这里就不在累述了
                 */
        else {
            Entry<K,V> sib = leftOf(parentOf(x));

            if (colorOf(sib) == RED) {
                setColor(sib, BLACK);
                setColor(parentOf(x), RED);
                rotateRight(parentOf(x));
                sib = leftOf(parentOf(x));
            }

            if (colorOf(rightOf(sib)) == BLACK &&
                colorOf(leftOf(sib)) == BLACK) {
                setColor(sib, RED);
                x = parentOf(x);
            } else {
                if (colorOf(leftOf(sib)) == BLACK) {
                    setColor(rightOf(sib), BLACK);
                    setColor(sib, RED);
                    rotateLeft(sib);
                    sib = leftOf(parentOf(x));
                }
                setColor(sib, colorOf(parentOf(x)));
                setColor(parentOf(x), BLACK);
                setColor(leftOf(sib), BLACK);
                rotateRight(parentOf(x));
                x = root;
            }
        }
    }

    setColor(x, BLACK);
}
```

这是红黑树在删除节点后，对树的平衡性进行调整的过程，其实现过程与上面四种复杂的情况一一对应，所以在这个源码的时候一定要对着上面提到的四种情况看。



## LinkedHashMap

https://blog.csdn.net/justloveyou_/article/details/71713781?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162814356316780357253422%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162814356316780357253422&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-5-71713781.pc_search_result_cache&utm_term=linkedhashmap&spm=1018.2226.3001.4187

HashMap和双向链表合二为一即是LinkedHashMap。所谓LinkedHashMap，其落脚点在HashMap，因此更准确地说，它是一个将所有Entry节点链入一个双向链表的HashMap。由于LinkedHashMap是HashMap的子类，所以LinkedHashMap自然会拥有HashMap的所有特性。比如，LinkedHashMap的元素存取过程基本与HashMap基本类似，只是在细节实现上稍有不同。当然，这是由LinkedHashMap本身的特性所决定的，因为它额外维护了一个双向链表用于保持迭代顺序。此外，LinkedHashMap可以很好的支持LRU算法


![image-20210805141100270](数据结构.assets/image-20210805141100270.png)



![https://blog.csdn.net/justloveyou_/article/details/71713781?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162814356316780357253422%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162814356316780357253422&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-5-71713781.pc_search_result_cache&utm_term=linkedhashmap&spm=1018.2226.3001.4187](数据结构.assets/image-20210805141113645.png)















































## B B+ B*树

### B树

B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个）

- 排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
- 子节点数：非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；
- 关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);
- 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;

![image-20210727001118341](数据结构.assets/image-20210727001118341.png)

- B树查询流程
  - 如上图我要从上图中找到E字母，查找流程如下
  - 获取根节点的关键字进行比较，当前根节点关键字为M，E<M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；
  - 拿到关键字D和G，D<E<G 所以直接找到D和G中间的节点；
  - 拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；

- B树插入节点流程
  - （1）节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须<=5-1（这里关键字数>4就要进行节点拆分）；
  - （2）排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;

- B树节点删除
  - （1）节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数<2就要进行节点合并）；
  - （2）满足节点本身比左边节点大，比右边节点小的排序规则;
  - （3）关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；

B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;

### B+树

B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。

- B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；
- B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；
- B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。
- 非叶子节点的子节点数=关键字数

![image-20210727001602614](数据结构.assets/image-20210727001602614.png)

- B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；

- B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

- B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
- B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。

### B*树

B*树是B+树的变种

- （1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b*树的初始化个数为（cei(2/3*m)）
- （2）B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；

在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；

### B树总结

1、相同思想和策略
从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度；

2、不同的方式的磁盘空间利用
不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的；