# 数据结构

## 简单动态字符串

> 总结

Redis只会用C字符串作为字面量, 大多数情况下使用SDS作为字符串表示

相比C字符串的优点

1. 常数复杂度获取SDS的长度
2. 杜绝缓冲区溢出
3. 二进制安全
4. 预分配空间 + 惰性释放减少修改字符串所需的内存重分配次数
5. 兼容部分C字符串的函数

### SDS (simple dynamic string)

- 无需对字符串值进行修改的地方, 使用C字符串

![1626853473498](redis.assets/1626853473498.png)

- 需要对字符串修改的地方使用SDS表示字符串值

![1626853482080](redis.assets/1626853482080.png)

### SDS定义

![1626853643464](redis.assets/1626853643464.png)

- 以空字符串结尾, 分配额外的一个自己的空间但是不计算到len 属性中
  - 保留这个C字符串的特性可以重用C的字符串函数库的函数
  - printf("%s", s->buf);



### SDS与C字符串的区别

![1626853755332](redis.assets/1626853755332.png)

![1626853769569](redis.assets/1626853769569.png)

#### 常数复杂度获取字符串的长度

- C字符串
  - 不记录本身的长度, 需要比例字符串知道遇到结尾的空字符, O(N)的操作
- SDS
  - SDS 的len属性记录了SDS本身的长度, 可以O(1)获取
  - 设置和更新SDS长度由SDS API在执行的时候自动完成
- 确保了获取字符串长度不会成为redis的性能瓶颈
- 字符串键底层通过SDS实现, 返回对一个字符串键调用 STRLEN, 不会对性能造成影响



#### 杜绝缓冲区溢出

![1626854006153](redis.assets/1626854006153.png)

- C
  - 调用某些C的字符串库函数, 因为不知道字符串的长度信息, 会造成缓冲区溢出
- redis
  - SDS API对字符修改的时候, 需要先检查SDS的空间是否足够, 如果不够会自动扩展至执行操作需要的大小,再执行实际的修改, 所以不存在缓冲区溢出的问题
  - sdscat(str1, str2) 会先检查str1的buf是否有足够的空间容纳str2, 不够的话先扩容再执行 



#### 减少修改字符串带来的内存重分配次数

![1626854279358](redis.assets/1626854279358.png)

- C
  - 增大字符串, 需要先扩展底层数组的大小, 否则会缓冲区溢出
  - 减少字符串, 需要先释放底层数组不使用的那部分空间, 否则会造成内存泄露

- redis
  - 避免频繁修改字符造成的内存重分配

> 通过空间预分配和惰性空间释放两种优化策略

##### 空间预分配

优化需要对SDS进行空间扩展的时候, 不仅分配修改需要的空间, 还会分配额外的未使用空间(free)

- 修改后SDS的长度(len)<1MB
  - 为这个SDS分配额外和SDS长度相同的额外未使用空间(free=len)
- 修改后SDS的长度(len)>=1MB
  - 为这个SDS分配1MB未使用的空间(free)

减少连续执行字符串增长操作所需的内存重分配次数, SDS将连续增长N次字符串所需的内存重分配次数从=N次降低到最多N次



##### 惰性空间释放

优化需要堆SDS字符串的缩短操作, 当需要缩短SDS的时候, 不立即使用内存重分配来回收多出来的字节, 而是将这些多出来的空间记录到free属性中, 这样将来如果需要进行增长操作, 未使用的空间就可以用上

通过惰性分配策略, SDS避免了缩短字符串所需的内存重分配操作, 并为将来的增长操作提供了优化



#### 二进制安全

![1626854892071](redis.assets/1626854892071.png)

- C
  - 字符串中除了末尾不能包含空字符, 否则被认为是字符串的结尾, 不能保存二进制数据
- redis
  - SDS API 以处理二进制的方式来处理保存在buf数组里的数据, 不做任何限制, 假设, 过滤, 写入什么样子读出来就是什么样子
  - 不仅可以保存文本数据也可以保存任意格式的二进制数据

#### 兼容部分C字符串函数

SDS API二进制安全但是仍然遵守C字符串以空字符串结尾的管理, 这样可以兼容部分C字符串函数



#### 区别总结

![1626855312662](redis.assets/1626855312662.png)

### SDS API

![1626855416592](redis.assets/1626855416592.png)

![1626855421769](redis.assets/1626855421769.png)





## 链表

- 提供了高效的结点重排能力, 通过顺序的访问方式, 可以加增删结点灵活调节链表的长度
- 官方使用: 列表键, 发布与订阅, 慢查询, 监视器
- 每个结点是一个ListNode, 拥有prev next 指向前后置结点, 链表的实现是双端队列
  - prev next value
- 每个链表是有list结构表示
  - head tail len dup() clear() match()
- head.prev = NULL tail.next=NULL 无环
- void *value 结点可以保存不同类型的值



### 链表和链表结点的实现

- 每个连接的结点

![1626855737464](redis.assets/1626855737464.png)

- 整个的链表

![1626855787034](redis.assets/1626855787034.png)

- dup 复制链表结点所保存的值
- free释放链表结点所保存的值
- match 对比链表结点所保存的值和另一个输入值是否相等

![1626855886838](redis.assets/1626855886838.png)

> 链表的特性

- 双端 prev next指针可以O(1)获取前置和后置结点
- 无环  head.prev = NULL tail.next = NULL
- O(1)获取头尾结点
- O(1) 通过len属性获取链表结点个数
- 多态 void\*保存结点值, 包括dup clear match函数的比较值都是void*  可以保存不同类型的值



### 链表和链表结点的API

![1626856119511](redis.assets/1626856119511.png)

![1626856175119](redis.assets/1626856175119.png)





## 字典

- 字典的每个键都是唯一的
- redis数据库, 哈希键的底层实现, 使用的是MurmurHash2哈希算法计算哈希值
- 字典使用哈希表作为底层实现, 每个字典有两个哈希表, 一个用于平时存储键值对, 另一个用于rehash时使用
- 哈希表 使用链地址法解决哈希冲突, 被分配到同一个索引上的多个键值对连城一个单向链表, 新的冲突的键值对被添加到链表的头
- 对哈希表的扩展或收缩操作需要将现有哈希表所有键值对rehash到新的哈希表中, 这是一个渐进式的过程

### 字典的实现

哈希表是Redis字典的底层实现, 一个哈希表可以有多个哈希表结点, 每个哈希表结点保存了字典中的一个键值对



#### 哈希表 (dictht)

![1626856549250](redis.assets/1626856549250.png)

- table
  - 是一个指针数组, 二级指针指向一个一个数组的起始位置
  - 数组中每个元素都是一个指向一个dict.h/dictEntry结构的指针
  - 每个dictEntry结构保存着一个键值对
- size
  - 哈希表的大小, table数组的大小
- used
  - 已有的结点数量
- sizemask
  - size-1
  - 和哈希值决定了一个键被放到table数组的那一个索引上

![1626857112929](redis.assets/1626857112929.png)

#### 哈希表结点(dictEntry)

dictEntry结构, 每个dictEntry结构保存一个键值对

![1626857271162](redis.assets/1626857271162.png)

![1626857284744](redis.assets/1626857284744.png)





#### 字典(dict)

![1626857313341](redis.assets/1626857313341.png)

##### type和privatedate

- 针对不同类型的键值对, 创建多态字典而设置的

- type
  - 指向dictType结构的指针, 每个dictType结构保存了一簇用于操作特定类型键值对的函数
  - redis会为用途不同的字典设置不同类型的函数
- privatedata
  - 保存了要传给哪些类型特定函数的可选参数

![1626857489565](redis.assets/1626857489565.png)

##### ht

大小为2的数组, 数组中的每个项都是一个dictht哈希表

- ht[0]是正常使用的哈希表
- ht[1]只会对ht[0]进行rehash的时候使用

##### rehashindex

rehashindex=-1 表示目前没有进行rehash

![1626857856648](redis.assets/1626857856648.png)

### 哈希算法

新的键值对要添加到字典中

1. 根据键值对计算哈希值和索引值
   1. ![1626858247145](redis.assets/1626858247145.png)
2. 根据索引值将包含新的键值对的哈希表结点放到哈希表数组的指定索引上

MurmurHash算法计算键的哈希值

- 即使输入的键很有规律也能给出很好的随机分布性

### 解决键的冲突

两个或以上数量的键被分配到了哈希表数组的同一个索引上

> 链地址法

每个哈希表结点都有一个next指针, 多个哈希表结点可以通过next指针构成一个单项链表

因为是单项链表没有指向链表表尾的指针, 每次总是将新节点添加到链表的表头位置O(1)



### rehash

当哈希表保存的键值对数量太多或者太少时, 需要对哈希表的大小进行相应的扩展和收缩

> rehash的步骤

1. 为字典的ht[1]哈希表分配空间, 分配的空间取决与执行的操作和ht[0].used的大小
   - 如果执行的扩展操作, ht[1] 大小 = 第一个大于等于 ht[0].used*2的2^n
   - 如果执行的是收缩操作, ht[1]大小=第一个大于等于ht[0].used的2^n
2. 将保存在ht[0]中的键值对rehash到ht[1]上
   - rehash就是根据键值对的键值以及ht[1].sizemask重新计算键的哈希值和索引值, 然后将键值对放到ht[1]对应索引的位置
3. ht[0]所有的键值对迁移到ht[1]上以后释放ht[0] 将ht[1]置为ht[0], 并在ht[1]的位置上创建一个空白的哈希表



![1626858945451](redis.assets/1626858945451.png)



- 分配ht[1]

![1626858972026](redis.assets/1626858972026.png)

- rehash

![1626858983522](redis.assets/1626858983522.png)

- 释放空间, 交换

![1626859003985](redis.assets/1626859003985.png)

#### 哈希表的扩展和收缩

执行扩展操作的条件

- 服务器没有执行BGSAVE || BGREWRITEAOF 命令, 并且哈希表的负载因子>=1
- 服务器正在执行BGSAVE || BGREWRITEAOF 命令, 并且哈希表的负载因子>=5

负载因子

- load_factor = ht[0].used / ht[0].size
- 负载因子 = 已保存的结点数量 / 哈希表大小

BGSAVE || BGREWRITEAOF 命令

- BGSAVE || BGREWRITEAOF 命令执行过程中 Redis需要创建紫禁城, 通过COW优化子进程的效率
- 所以需要提高扩展操作所需的负载因子来避免子进程存在期间进行哈希表扩展操作, 
- 避免不必要的内存写入操作, 节约内存

收缩操作的必要条件

- 负载因子<0.1

### 渐进式rehash

rehash的操作不是一次性集中式的完成, 而是分多次渐进式的完成的

#### 为什么分多次渐进式的进行rehash

如果ht[0]保存的键值对数量过多, 一次性将这些键值对全部rehash到ht[1]庞大的计算量可能导致服务器停止一段时间, 使用分多次渐进式的rehash可以避免这种因为瞬时的大量计算导致的服务器停止

#### 渐进式rehash的步骤

1. 为ht[1]分配空间, 让字典同时持有ht[0] 和 ht[1]两个哈希表
2. 字典中维护一个索引计数器遍变量 rehashidx=0 
3. rehash期间进行的对字典的增删改查操作除了指向指定操作外, 都将操作对应的索引上的所有键值对rehash到ht[1], 此次rehash工作完成后rehashidx+1
4. 当ht[0]所有的键值对都rehash到ht[1]以后, rehashidx=-1标志rehash操作完成

这样分而治之的方式, 可以将rehash键值对所需的工作均摊到每个队字典的增删改查操作中, 避免了集中式rehash带来的庞大的计算量



#### 渐进式rehash期间的哈希表操作

- 查找
  - 先在ht[0]中找, 没有找到会到ht[1]中找
- 添加
  - 新添加的键值对一律添加到ht[1], 保证了ht[0]的数量只减不增

### 字典API

![1626859954995](redis.assets/1626859954995.png)





## 跳跃表

- 跳跃表是一种有序数据结构, 是有序集合的底层实现之一
- 由zskiplist 和 zskiplistNode两个结构组成
  - zskiplist保存跳跃表信息(头尾结点, 长度)
  - zskiplistNode表示跳跃表结点
- 每个跳跃表的层高都是1-32的随机数
- 同一个跳跃表中多个结点可以包含相同的分值(score)但是每个结点的成员对象必须是唯一的
- 跳跃表按照分值进行排序, 分值相同的按照成员对象大小排序
- 通过在每个结点维持多个指向其他节点的指针, 从而达到快速访问结点的目的
- 平均支持O(log N) 最坏O(N)的结点查找, 还可以通过顺序性操作完成批处理结点
- 只有在实现有序集合键, 在集群结点中用作内部数据结构用到



### 跳跃表的实现

redis.h/zskiplistNode跳跃表结点 redis.h/zskiplist保存跳跃表结点相关信息 两个结构定义

![1626861854743](redis.assets/1626861854743.png)

#### zskiplist

<img src="redis.assets/1626862783104.png" alt="1626862783104" style="zoom:50%;" />



- head  tail 跳跃表的头尾结点
- level 记录目前跳跃表内, 层数最大的那个结点的层数(表头结点的层数不算在内)
- length 跳跃表的长度即跳跃表的结点数(表头结点不算在内)





#### 跳跃表结点 zskiplistNode

![1626862027925](redis.assets/1626862027925.png)

- 层 level: 
  - 结点的level数组可以包含多个元素, 每个元素都是一个指向其他节点的指针, 可以通过这些层来加快访问其他节点的速度
  - 每次创建新的跳跃表结点都会随机生成一个1-32之间的值作为level数组的大小即高度
  - 结点中 L1 L2 L3...表示各个层, L1表示第一层 L2 表示第二层 以此类推
  - 每个层有两个属性: 前进指针和跨度
    - 前进指针用于方位位于表尾方向的结点
    - 跨度记录了前进指针指向的结点与当前结点的距离
  - 从表头向表尾遍历时, 访问会沿着层的前进指针进行

![1626862258069](redis.assets/1626862258069.png)

- 前进指针
  - 每一层都有一个指向表尾方向的前进指针, (level[i].forward) 用于从表头向表尾方向的访问

![1626862334458](redis.assets/1626862334458.png)

- 跨度
  - 记录连个结点之间的距离(level[i].span)
  - 跨度实际与遍历操作无关, 是用来计算排位的(rank)
  - 在查找某个结点的过程中, 将沿途访问过的所有层的跨度累计起来, 得到的结果就是目标结点在跳跃表中的排位

- 后退指针(backward)
  - BW是后退指针, 指向位于当前结点的前一个结点, 用于从表尾向表头遍历
  - 每个结点只有一个BW指针, 只能回退到前一个结点

- 分值(score)
  - 结点按照各自的分值从小到大排列(double类型)
- 成员对象(obj)
  - 是一个指针, 指向一个字符串对象, 字符串对象保存一个SDS的值
  - 同一个跳跃表中, 各个结点保存的成员对象必须是唯一的, 但是多个结点保存的分值可以相同
  - 分值相同的结点将按照成员对象在字典序中的大小来进行排序
  - 成员对象小的结点排在前面, 大的在后面



### 跳跃表API

![1626862828105](redis.assets/1626862828105.png)





## 整数集合

- 集合键的底层实现之一
- 当一个集合只包含整数, 并且元素数量不多就会使用整数集合
- 整数集合的底层实现是数组, 数组以有序, 无重复的方式保存集合元素, 在需要的时候根据新添加元素的类型对数组的类型进行调整
- 升级操作带来了整数集合的灵活性已经节约了内存
- 只支持升级不支持降级

### 整数集合的实现

用于保存整数值集合的抽象数据结构, 保存类型为 int16_t int32_t int64_t 并且保证元素不重复

![1626863755506](redis.assets/1626863755506.png)





- contents数组是整数集合的底层实现
  - 整数集合的每个元素都是contents数组的一个数组项(item) 各个项在数组中从小到大排列并且不重复
- length
  - 数组的长度, 整数集合包含的元素数量
- content数组的真正类型取决于encoding属性的值



### 升级

当添加的新元素类型比整数集合所有元素的类型都要长时, 整数集合需要先升级, 才能将新元素添加到整数集合

升级集合并添加元素的步骤

1. 根据新元素的类型, 扩展整数集合底层数组的空间大小, 并为新元素分配空间
2. 将底层数组所有的元素都转换成和新元素相同的类型, 并将类型转换后的元素放置到正确的位置上, 而且放置元素的过程中, 需要位置底层数组的有序性质
3. 将新元素添加到底层数组中

因为每次向整数集合添加元素都有可能引起升级, 而每次升级都需要将所有元素进行类型转换, 所以时间复杂度O(N)

![1626864729468](redis.assets/1626864729468.png)

![1626864740960](redis.assets/1626864740960.png)

- 添加一个int32_t类型的65535 需要升级 升级后

![1626864792519](redis.assets/1626864792519.png)

![1626864783557](redis.assets/1626864783557.png)

![1626864901600](redis.assets/1626864901600.png)





### 升级的好处

提升整数集合的灵活性和尽可能的节约内存

#### 提升灵活性

![1626864965775](redis.assets/1626864965775.png)



#### 节约内存

![1626864990150](redis.assets/1626864990150.png)

![1626864995381](redis.assets/1626864995381.png)



### 降级

整数集合不支持降级操作, 一旦升级, 就会保持升级后的状态

即使删除了造成整数集合升级的元素, 底层数组仍然不变

可能是因为各个元素都已经按照升级后的类型进行了位置的调整, 占据的位数已经是升级后类型的位数, 如果升级又带来一系列类型转换, 元素移动的操作, 可能会非常耗时



### 整数集合API

![1626865157661](redis.assets/1626865157661.png)



## 压缩列表

- 压缩列表是列表键和哈希键的底层实现之一
  - 当一个列表键只有少量列表项, 并且每个列表项是小整数 || 短字符串
  - 键值对的键和值都是小整数||短字符串
- 压缩列表是一种为节约内存而开发的顺序型数据结构
- 可以包含多个结点, 每个结点包含一个字节数组或者整数值
- 添加或者删除结点可能会导致连锁更新



### 压缩列表的构成

一系列特殊编码的连续内存块组成的顺序型数据结构

一个压缩列表可以包含任意多个结点, 每个结点都可以保存一个字节数组或者一个整数值

![1626865840990](redis.assets/1626865840990.png)

![1626865952658](redis.assets/1626865952658.png)

### 压缩列表结点的构成

![1626866054511](redis.assets/1626866054511.png)

#### previous_entry_length

以字节为单位, 记录前一个结点的长度, 属性的长度可以使1 || 5 个字节

- 前一个结点的长度<254bytes  previous_entry_length属性长度是1字节, 前一个结点长度就保存在这个属性中
- 前一个结点的长度>=254bytes  previous_entry_length属性长度是5字节, 属性的第一字节被设置为0xFE(254), 而之后的四个字节保存前一个结点的长度

![1626866286758](redis.assets/1626866286758.png)

可以通过指针运算, 根据当前结点的起始地址计算前一个结点的起始地址

![1626866355444](redis.assets/1626866355444.png)

压缩列表从表尾向表头遍历操作就是利用指针运算的原理, 

- 当我们拥有一个指向某个结点起始地址的指针, 以及这个结点的previous_entry_length属性就可以获得前一个结点的起始地址, 进而一直到达头结点

![1626866490204](redis.assets/1626866490204.png)

#### encoding

记录了结点的content属性所保存数据的类型和长度

![1626866607466](redis.assets/1626866607466.png)

![1626866889217](redis.assets/1626866889217.png)



#### content

保存结点的值, 结点值可以是一个字节数组, 或者整数, 类型和长度由encoding决定

![1626867142512](redis.assets/1626867142512.png)

### 连锁更新

> 特殊情况下产生的连续多次空间扩展操作称之为连锁更新 cascade update

 previous_entry_length属性以字节为单位, 记录前一个结点的长度, 属性的长度可以使1 || 5 个字节

- 前一个结点的长度<254bytes  previous_entry_length属性长度是1字节, 前一个结点长度就保存在这个属性中
- 前一个结点的长度>=254bytes  previous_entry_length属性长度是5字节, 属性的第一字节被设置为0xFE(254), 而之后的四个字节保存前一个结点的长度

> 在一个压缩列表中, 有多个连续的长度介于[250, 253]字节的结点e1~eN

![1626867225724](redis.assets/1626867225724.png)

因为结点长度<254, 记录这些结点的长度只需要1字节的 previous_entry_length属性

这是将一个长度>=254字节的新节点new 设置为压缩列表的表头结点, 即e1的前置结点

![1626867322209](redis.assets/1626867322209.png)

因为e1 previous_entry_length属性仅为1字节, 空间不够需要对压缩列表进行空间重新分配, 

将e1 previous_entry_length属性扩展为5字节, 

这会导致e1的长度变成[254,257]之间, 造成后续节点的previous_entry_length属性的更新直到eN为止

除了添加, 删除也会导致连锁更新, 删除了中间的某个结点导致删除结点的后一个结点需要存储删除结点的前一个的长度, 而这个长度大于后一个结点 previous_entry_length属性所能装下的空间进而导致连锁更新

![1626867642378](redis.assets/1626867642378.png)

![1626867662375](redis.assets/1626867662375.png)

### 压缩列表API

![1626867692455](redis.assets/1626867692455.png)

![1626867718477](redis.assets/1626867718477.png)

# 对象

- 每个键值对的键和值都是一个对象
- 共有字符串, 列表, 哈希, 集合, 有序集合五种类型的对象
  - 每种类型都有至少两种或以上的编码方式, 不同编码应用于不同的场景优化
- 服务器执行命令前会检查给定键的值对象的类型是否符合
- 引用计数实现内存回收, 当一个对象的refcount=0 占用的内存会被释放
- 共享0~9999的字符串对象
- 对象会记录自己最后一次被访问的时间, 这个时间可以用于计算对象的空转时间







Redis不直接使用这些数据结构实现键值对, 而是基于这些数据结构创建一个对象系统

字符串, 列表, 哈希, 集合, 有序集合对象

针对不同的使用场景为对象设置不同的数据结构来实现, 从而优化使用效率

基于引用计数计数的垃圾回收机制

基于引用计数实现对象的共享机制, 多个数据库共享同一个对象来节约内存

对象带有访问时间可以计算数据库键的空转时间



## 对象类型与编码

数据库每创建一个键值对, 都会至少创建两个对象用来表示键和值

每个对象都是一个redisObject

![1626870773962](redis.assets/1626870773962.png)

### 类型

![1626870898515](redis.assets/1626870898515.png)

type属性记录了对象的类型

- 键总是一个字符串对象
- 值可以是字符串, 列表, 哈希, 集合, 有序集合对象中的一种

type <数据库键>:

- 返回键对应值的对象类型, 因为键总是字符串对象

![1626870995866](redis.assets/1626870995866.png)

### 编码和底层实现

ptr

- 对象的ptr指针指向底层实现数据结构, 数据结构由对象的encoding属性决定

encoding

- 记录了对象所使用的编码, 也就是对象使用了什么数据结构作为对象的底层实现

![1626871126312](redis.assets/1626871126312.png)

每种类型的对象都使用了至少两种不同的编码

![1626871288867](redis.assets/1626871288867.png)

OBJECT ENCODING 查看一个数据库键的值对象的编码

![1626871359418](redis.assets/1626871359418.png)

![1626871366211](redis.assets/1626871366211.png)

通过encoding属性可以设定对象所使用的编码, 而不是为特定类型的对象关联固定的编码, 极大地低声了Redis的灵活性和效率, Redis可以根据不同的场景来为对象设置不同的编码, 优化某一场景下的效率

![1626871496888](redis.assets/1626871496888.png)



## 字符串对象(int embstr raw)

字符串对象的编码可以是 int  raw 或 embstr

### int

- 字符串对象保存的是整数值, 并且这个整数值可以用long类型来表示
- 字符串对象会把整数值保存在对象结构的ptr属性里面(void* --> long)
- 并将对象的编码设置为int

![1626872008737](redis.assets/1626872008737.png)



### raw

- 保存字符串, 长度>32字节
- 使用SDS来保存这个字符串值
- 对象编码设为raw

![1626872101524](redis.assets/1626872101524.png)



### embstr

- 保存字符串, 长度<=32字节
- 使用embstr编码的方式保存这个字符串值



embstr编码是专门保存短字符串的优化编码方式, 和raw一样用了redisObject和sdshdr结构来表示字符串对象

- raw调用两次内存分配分别创建redisObject 和 sdshdr结构
- embstr编码通过调用一次内存分配一块连续的空间 依次包含redisObject和sdshdr两个结构

![1626872298250](redis.assets/1626872298250.png)

embstr编码的字符串保存段字符串值的好处

- 内存分配次数只需一次
- 释放字符串对象时序调用一次内存释放函数
- 字符串对象的所有数据都保存在一块连续的内存里, 所以能更好的利用缓存带来的优势

![1626872422899](redis.assets/1626872422899.png)

long double类型表示的浮点数在redis也是作为字符串的值来保存

![1626872511273](redis.assets/1626872511273.png)



### 编码的转换

int embstr在条件满足的情况下会转换成raw

int

- 向对象执行了一些命令, 使得这个对象保存的不再是整数值, 而是一个字符串值, 那么字符串对象编码会变成raw
- ![1626872690081](redis.assets/1626872690081.png)

embstr

- embstr编码的字符串没有任何修改程序, 实际上是只读的
- 所以修改前编码必须从embstr改成raw, 
- ![1626872786210](redis.assets/1626872786210.png)

### 字符串命令

![1626872905981](redis.assets/1626872905981.png)



## 列表对象(ziplist linkedlist)

编码可以是ziplist 或者 linkedlist

### ziplist

- ziplist编码的列表对象底层实现为压缩列表, 每个压缩列表结点保存一个列表元素, 

![1626873202065](redis.assets/1626873202065.png)

![1626873207516](redis.assets/1626873207516.png)



### linkedlist

-  linkedlist编码的列表对象底层实现为双端链表
- 每个双端链表结点保存了一个字符串对象, 字符串对象保存了一个列表元素

![1626873457515](redis.assets/1626873457515.png)

字符串对象是Redis五中类型的对象中唯一会被其他四种对象嵌套的对象

![1626873557596](redis.assets/1626873557596.png)

![1626873535969](redis.assets/1626873535969.png)

### 编码转换

列表对象满足下面条件可以使用ziplist编码

- 列表对象保存的所有字符串元素的长度都小于64字节
- 列表对象保存的元素数量小于512

不能满足这两个条件的都需要使用linkedlist编码

当ziplist编码的列表对象改变导致上述两个条件不能满足时会自动转换编码将裂变元素转移到双端链表中

- 插入了大字符串长度大于64字节
- 增加了元素数量使得总数量超过512

### 列表命令的实现

![1626873912472](redis.assets/1626873912472.png)





## 哈希对象(ziplist hashtable)

ziplist 或 hashtable编码

### ziplist

- ziplist编码的哈希对象底层使用压缩列表
- 新的键值对加入哈希对象, 先将保存了键的压缩列表结点推入压缩列表结尾
- 再将保存了值的压缩列表结点推入压缩列表结尾
- 保证了同一键值对的两个结点总是紧挨在一起的, 键在前, 值在后
- 先添加到哈希对象的键值对在表头方向, 后添加的在表尾方向

![1626874177742](redis.assets/1626874177742.png)

### hashtable

- hashtable编码的哈希对象使用字典作为底层实现, 哈希对象的每个键值对都由一个字典键值对来保存
  - 字典的每个键都是一个字符串对象, 对象保存了键值对的键
  - 字典的每个值都是一个字符串对象, 对象保存了键值对的值

![1626874303900](redis.assets/1626874303900.png)



### 编码转换

满足使用ziplist编码的条件

- 哈希对象保存的所有键值对的键和值的字符串长度都<64字节
- 哈希对象保存的所有键值对的数量<512

不满足的都需要使用hashtable

当ziplist编码所需的两个条件任意一个不能满足的时候都需要转换成hashtable编码

- 添加新的键值对 键或值长度>=64字节
- 加入的键值对数量总和>=512



### 哈希命令的实现

![1626874520298](redis.assets/1626874520298.png)



## 集合对象(intset hashtable)

### intset

使用整数集合作为底层实现, 

集合对象包含的所有元素都被保存在整数集合里面

![1626875014749](redis.assets/1626875014749.png)

### hashtable

使用字典作为底层实现, 

字典的每个键都是一个字符串对象, 

每个字符串对象包含一个集合元素, 

字典的值全部设为NULL

![1626875080128](redis.assets/1626875080128.png)

### 编码转换

intset编码的条件

- 集合对象所有元素都是整数值
- 元素个数<=512

不满足的需要用hashtable编码

- 在intset编码的集合对象插入一个字符串元素
- 集合元素个数超过512



### 集合命令的实现

![1626875354637](redis.assets/1626875354637.png)

![1626875433095](redis.assets/1626875433095.png)



## 有序集合对象(ziplist skiplist)

### ziplist

使用压缩列表作为底层实现

每个集合元素使用两个挨在一起的压缩列表结点保存, 

第一个保存元素的成员(member) 第二个保存元素的分值(score)

压缩列表内的集合元素按照分值从小到大排序

![1626875581095](redis.assets/1626875581095.png)

![1626875585836](redis.assets/1626875585836.png)

![1626875599472](redis.assets/1626875599472.png)



### skiplist

使用zset结构作为底层实现, 一个zset结构同时包含一个字典和一个跳跃表

```c
typedef struct zset{
    //跳跃表
    zskiplist *zsl;
    //字典
    dict *dict;
}zset;
```



#### zsl跳跃表

按分值从小到大保存了所有集合的元素,

每个跳跃表结点都保存了一个集合元素

跳跃表结点的object 属性保存了元素的成员

score属性保存了元素的分值

通过这个跳跃表可以对有序集合进行范围型操作 (ZRANK ZRANGE)



#### dict字典

为有序集合创建一个从成员到分值的映射

字典的每个键值对都保存了一个集合元素

字典的键保存了一个元素的成员

字典的值保存了一个元素的分值

可以用O(1)复杂度找到给定成员的分值

ZSCORE就时根据这一特性实现的



有序集合的每一个元素的成员都是一个字符串对象

每个元素的分值都是一个double类型的浮点数

虽然同是使用了跳跃表和字典保存集合元素, 但是都是通过指针共享相同元素的成员和分值, 不会造成重复



#### 为什么同是使用跳跃表和字典来实现?

字典保证了O(1)查找指定成员的分值

跳跃表保证了可以进行范围操作而无需对整体的成员进行排序

![1626876186222](redis.assets/1626876186222.png)



![1626876429882](redis.assets/1626876429882.png)

### 编码转换

使用ziplist的条件

- 有序集合元素数量<128
- 保存元素的成员长度都<64字节

不能满足的都要使用skiplist编码

- 有序集合元素数量>=128
- 插入元素成员长度>=64字节



### 有序集合命令的实现

![1626876859974](redis.assets/1626876859974.png)



## 类型检查和命令多态

操作键的基本命令

- 对任意类型键执行
  - DEL EXPIRE RENAME TYPE OBJECT

- 对特定类型键执行
  - ![1626876987189](redis.assets/1626876987189.png)



### 类型检查的实现

为了确保只有指定类型的键才可以执行某些特定的命令, 执行之前会先检查输入键的类型是否正确, 然后决定是否执行

类型特定命令通过redisObject结构的type属性实现

- 执行类型特定命令前, 服务器会先检查输入数据库键的值对象是否为执行命令所需要的类型, 是的话才执行

![1626877207094](redis.assets/1626877207094.png)



### 多态命令的实现

根据对象编码方式 选择正面的命令实现代码来执行命令

在确保了值对象类型符合命令要求, 还需要根据值对象的底层实现调用对应的底层函数完成高层命令

LLEN返回列表的长度, 根据底层实现的不同使用不同的函数获取长度

- ziplist --> ziplistLen
- linkedlist --> listLength

![1626877301584](redis.assets/1626877301584.png)

![1626877432755](redis.assets/1626877432755.png)



## 内存回收

构建引用计数计数实现内存回收机制, 跟踪对象的引用计数信息, 在适当的时候释放对象进行内存回收

![1626877494826](redis.assets/1626877494826.png)

- 创建初始refcount=1
- 增加引用refcount+1
- 减少引用refcount-1
- refcount==0 释放

![1626877515162](redis.assets/1626877515162.png)

![1626877565954](redis.assets/1626877565954.png)

![1626877586596](redis.assets/1626877586596.png)



## 对象共享

对象的引用计数属性还有对象共享的作用

让多个对象共享同一个值对象需要两个步骤

1. 将数据库键的值指针指向一个现有的值对象
2. 被共享的值对象的引用计数refcount+1

![1626877740828](redis.assets/1626877740828.png)





redis在初始化服务器的时候, 创建10000个字符串对象, 包含了0~9999所有的整数值, 当需要的时候共享这些字符串对象, 而不是创建新的对象

![1626877830817](redis.assets/1626877830817.png)

为什么不共享包含字符串的对象

![1626877895084](redis.assets/1626877895084.png)



## 对象空转时间

redisObject的 lru属性记录了对象最后一次被命令程序访问的时间

![1626877956537](redis.assets/1626877956537.png)



OBJECT IDLETIME = 当前时间 - 键的值对象的lru

![1626878018456](redis.assets/1626878018456.png)



# 数据库

- redisServer.db数组保存了redis服务器所有的数据库, redisServer.dbnum保存数据库的数量
- 通过修改redisClient.db指针 让他指向redisServer.db数组中的不同元素来切换不同数据库
- 数据库redisDb主要由dict expires两个字典构成
  - dict保存所有键值对
  - expires保存设置过期时间 生存时间的过期时间
- 数据库由字典构成, 数据库的操作都是建立在字典之上
- 数据库键总是字符串对象, 值可以是 字符串, 列表, 哈希, 集合, 有序集合对象五种中任意一种
- expires字典的键指向数据库中的某个键, 值记录了键的过期时间, 过期时间是以毫秒为单位的UNIX时间戳
- Redis使用定期删除和过期删除两种策略删除过期键
  - 惰性删除: 碰到过期键才删除
  - 定期删除: 每隔一段时间周期性在所有数据库的expires字典中检查一部分键, 如果过期就删除
    - 下一次删除会从上一次删除的地方接着删除
- 执行SAVE BGSAVE命令产生的RDB文件不会包含过期键
- 执行BGREWRITEAOF命令产生的AOF文件不会包含过期键
- 当删除一个过期键时, 服务器会追加一条DEL命令到现有AOF文件的末尾, 显示的删除过期键

- 主服务器显示删除一个过期键会向所有从服务器发送一条DEL命令, 让从服务器删除过期键
- 从服务器即使发现一个过期键也不会主动删除, 而是等待主服务器的DEL命令, 这种中心化的过期键删除策略可以保证主从服务器的一致性
- Redis命令对数据库进行修改, 服务器根据配置向客服端发送数据库通知





服务器保存数据库的方法

客户端切换数据库的方法

数据库保存键值对的方法

数据库的CRUD

服务器保存键的过期时间的方法

服务器自动删除过期键的方法

通知功能的实现



## 服务器中的数据库

redis服务器的数据库保存在服务器redis.h/redisServer结构的db数组中

db数组中的每项都是一个redis.redisDb结构

每个redisDb结构代表一个数据库

![1626879645635](redis.assets/1626879645635.png)

初始化服务器, 根据服务器的dbnum属性来决定应该创建多少个数据库

![1626879680791](redis.assets/1626879680791.png)

dbnum 默认为16

![1626879710164](redis.assets/1626879710164.png)

## 切换数据库

每个客户端都有自己的目标数据库

默认目标数据库是0号数据库就是db数组中的db[0]

客户端可以通过select命令切换目标数据库 select [数据库在db数组中的索引]

服务器内部redisClient结构的db属性记录了客服端当前的目标数据库, 这个属性是指向redisDb结构的指针

![1626879912917](redis.assets/1626879912917.png)



![1626879927446](redis.assets/1626879927446.png)



> select命令的原理

通过修改redisClient.db指针指向服务器的不同数据库, 达到切换数据库的目的



## 数据库键空间

Redis是一个键值对数据库服务器

每个数据库由一个redis.h/redisDb结构表示

redisDb结构的dict字典保存了数据库中所有的键值对, 这个字典就是**键空间(key space)**

![1626880075744](redis.assets/1626880075744.png)

键空间和用户所见的数据库是直接对应的

- 键空间的键是数据库的键, 每个键都是一个字符串对象
- 键空间的值是数据库的值, 每个值可以是字符串, 列表, 集合, 哈希, 有序集合对象中任意一种redis对象

![1626880221934](redis.assets/1626880221934.png)

![1626880291969](redis.assets/1626880291969.png)



### 添加新键

添加新键值对就是将一个新的键值对添加到键空间字典里面

- 键为字符串对象, 值为任意一种类型的redis对象



### 删除键

删除数据库的键就是在键空间字典里面删除所对应的键值对对象



### 更新键

更新数据库的键就是对键空间里面键所对应的值对象进行更新, 根据值对象类型不同, 更新的具体方法不同



### 对键取值

对数据库键进行取值, 实际上就是在键空间中取出键对应的值对象, 根据值对象类型不同, 具体的取值方法不同



### 其他键空间操作

针对数据库本身的命令起始就是针对键空间的操作

- FLUSHDB
  - 删除键空间所有的键值对
- RANDOMKEY
  - 在键空间随机返回一个键
- DBSIZE
  - 返回数据库键数量就是返回键空间中包含的键值对的数量
- EXIST RENAME KEYS
  - 都是通过键空间进行操作实现的



### 读写键空间的维护操作

- 读取一个键, 根据键是否存在更新服务器的键空间命中(hit)或键空间不命中(miss)次数
  - INFO stats 的keyspace_hits keyspace_misses
- 读取一个键, 跟新键的LRU, 用于计算键的闲置时间
  - OBJECT idletime <key> 查看key的空闲时间
- 读取一个键, 发现键已经过期
  - 删除过期键, 然后执行余下的操作
- WATCH命令监视了某个键, 服务器堆被监视的键进行了修改后, 这个键标记为dirty , 让食物程序注意到键已经被修改过
- 每修改一个键之后, , 都会对脏键计数器值+1, 计数器会触发服务器的持久化以及复制操作
- 服务器开启了数据库通知功能, 会在堆键进行修改后, 按照配置发送相应的数据库通知



## 设置键的生存或过期时间

- EXPIRE PEXPIRE

通过EXPIRE 或 PEXPIRE 命令, 客户端可以以秒或者毫秒为数据库的键设置生存时间(Time To Live TTL) 指定的时间后, 服务器会自动删除生存时间为0 的键

(SETEX 在设置一个字符串键的同时设置过期时间)

- EXPIREAT PEXPIREAT

以秒或者毫秒精度给数据库中的键设置过期时间(expire time)

过期时间是一个UNIX时间戳, 当键的过期时间来临时, 服务器会自动从数据库中删除这个键

- TTL PTTL

接受一个带有生存时间或者过期时间的键, 返回这个键的剩余生存时间



### 设置过期时间

- EXPIRE <key> <ttl> 生存时间设置为ttl秒
- PEXPIRE <key> <ttl> 生存时间设置为ttl毫秒
- EXPIREAT <key> <timestamp> 过期时间设置为 timestamp秒数时间戳
- PEXPIREAT <key> <timestamp> 过期时间设置为 timestamp毫秒数时间戳

EXPIRE  PEXPIRE EXPIREAT 都是通过PEXPIREAT实现的

- EXPIRE --> PEXPIRE --> PEXPIREAT
- EXPIREAT --> PEXPIREAT

![1626882892919](redis.assets/1626882892919.png)

### 保存过期时间

redisDb结构的expires字典保存了数据库中所有键的过期时间, 过期字典

- 过期字典的键是一个指针, 指向了键空间的某个键对象
- 过期字典的值是一个long long类型的整数, 保存了键所指向的数据库键对象的过期时间
  - 一个毫秒精度的UNIX时间戳

```c
typedef struct redisDb{
    //过期字典
    dict *expires;
}redisDb;
```

![1626883127063](redis.assets/1626883127063.png)

当客户端执行PEXPIREAT命令, 为一个数据库键设置过期时间, 服务器会在数据库的过期字典中关联给定的数据库键和过期时间

![1626883217149](redis.assets/1626883217149.png)

### 移除过期时间

PERSIST 移除一个键的过期时间

PERSIST 命令在过期字典查找给定的键, 并解除键和过期时间在过期字典的关联



### 计算并返回剩余生存时间

TTL单位为秒, PTTL单位为毫秒

通过计算过期时间和当前时间之间的差来实现的



### 过期键的判定

![1626883404594](redis.assets/1626883404594.png)



## 过期键的删除策略

键过期了, 什么时候删除?



### 定时删除

优点

- 对内存友好

- 通过使用定时器, 保证过期键尽快被删除, 并释放过期键所占用的内存

缺点

- 对CPU不友好
- 过期键较多的时候会占用一部分CPU时间

创建定时器需要用到时间事件

- 时间事件的实现方式 无序链表
- 查找一个时间的时间复杂度O(N) 不能高效处理大量时间事件

### 惰性删除

优点

- 对CPU友好
- 只有在取出过期键时才会删除, 并且只会删除当前处理的键, 不会删除其他无关的键

缺点

- 内存不友好
- 过期键不删除, 始终占用内存, 内存不会被释放

### 定期删除

定时删除占用太多的CPU时间, 影响服务器的响应时间和吞吐量

惰性删除浪费太多内存, 有内存泄露的风险

定期删除采用整合折中的方法

- 每隔一段时间执行一次删除过期键的操作, 并限制删除操作执行的时长和频率来减少堆CPU的影响
- 减少了内存的浪费

难点是确定删除操作执行的时长和频率

- 如果删除操作执行太长或者频率过高就会退化成定时删除, 消耗过多的CPU
- 如果太短或者频率太低, 退化成惰性删除, 出现内存浪费



## Redis过期键删除策略

redis服务器实际使用**惰性删除**和**定期删除**两种, 通过两者的配合在合理使用CPU时间和避免浪费内存中平衡

### 惰性删除策略的实现

db.c/expireIfNeed函数实现, 所有读写数据库的Redis命令在执行前都会调用expireIfNeed函数对键进行检查

- 如果键已经过期, expireIfNeed会将输入键从数据库删除
- 未过期 不做任何操作

expireIfNeed函数像一个过滤器, 过滤掉过期的键, 避免命令接触到过期键

![1626884492574](redis.assets/1626884492574.png)



### 定期删除策略的实现

redis.c/activeExpireCycle 实现

每当Redis服务器周期性的操作 redis.c/serverCron函数, activeExpireCycle函数机会被调用

在规定时间分多次遍历服务器的各个数据库, 从数据库的expires字典中随机检查一部分键的过期时间, 并删除其中过期的键

![1626884711294](redis.assets/1626884711294.png)

![1626884699313](redis.assets/1626884699313.png)



## AOF RDB 赋值功能对过期键的处理

### 生成RDB文件

指向SAVE 或者BGSAVE命令创建一个新的RDB文件时, 会检查数据库中的键, 过期键不会保存到 新创建的RDB文件中

### 载入RDB文件

启动Redis服务器时, 如果服务器开启了RDB功能, 服务器会将RDB文件载入

- 如果服务器以主服务器运行, 载入RDB文件时, 会对文件中保存的键进行检查, 未过期的才会载入数据库
- 如果以从服务器模式运行, 载入RDB文件会保存所有的键, 不论是否过期
  - 因为主从服务器再进数据同步的时候,从服务器数据库会被情况, 所以一般不会有影响



### AOF文件写入

当服务器以AOF持久化模式运行, 如果数据库中的某个键过期了, 还没有被定期或者惰性删除, AOF文件不会因为这个过期键产生任何影响

当过期键被惰性删除或者定期删除之后, 会向AOF文件追加一条DEL命令 来显式的记录该键已经删除

如果get message试图访问 过期键message

1. 从数据库删除message键
2. 追加一条DEL message命令到AOF
3. 向执行get命令的客服端返回空回复



### AOF重写

执行AOF重写, 会检查数据库中的键, 过期键不会保存到重写后的AOF文件中



### 复制

运行在赋值模式下, 从服务器的过期键删除动作由主服务器控制

- 主服务器在删除一个过期键后, 会显式的向所有的从服务器发送一个DEL命令, 告诉从服务器删除这个过期键
- 从服务器执行客户端发送的读命令, 即使碰到过期键也像未过期键一样处理
- 从服务器只有收到主服务器传来的DEL命令才会删除过期键

通过主服务器统一的删除过期键可以保证主从服务器数据的一致性, 所以当一个过期键存在于主服务器, 这个过期键的复制品仍然存在于从服务器



## 数据库通知

让客服端通过订阅给定的频道或者模式, 来获取数据库键的变化, 以及数据库中命令的执行情况

- 键空间通知(key-space notification)
  - 关注某个键执行了什么命令
  - ![1626886665283](redis.assets/1626886665283.png)
- 键时间通知(key-event notification)
  - 某个命令被什么键执行了
  - ![1626886673232](redis.assets/1626886673232.png)

![1626886772264](redis.assets/1626886772264.png)



### 发送通知

notify.c/notifyKeySpaceEvent

![1626886828236](redis.assets/1626886828236.png)

- type
  - 当前想要发送的通知的类型, 根据这个值判断通知是否是服务器配置的 notify-keyspace-event选项选定的通知类型, 从而决定是否发送
- event keys dbid 分别是事件名称, 产生事件的键, 产生事件的数据库号码
- 函数会根据type参数以及这三个参数构建事件通知的内容, 记忆就收通知的频道名
- 每当一个Redis命令需要发送数据库通知, 该命令的实现函数会调用notify-KeyspaceEvent函数, 并向函数传递该命令所引发事件的相关信息



### 发送通知的实现

![1626887228368](redis.assets/1626887228368.png)

![1626887211695](redis.assets/1626887211695.png)



































































































